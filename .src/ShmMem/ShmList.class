' Gambas class file

' Author Westwood JustLostintime
'Released Under:
'  GNU GENERAL Public LICENSE
'  Version 3, 29 June 2007
'  See project license file.

Export
'Fast Unsafe

''' Defines the Shm datatype - list
''' Lists are inherited by every other list based object

Public Struct AllocHeader              '' Standard header
    Length As Long                              '' Length including header
    Address As Pointer                      '' The virtual address of this block, speed pointer conversion
    Type As Integer                             '' Type of memory
    {Next} As Pointer                          '' null if no more in list
End Struct

'' This is a virtual pointer to a value in shared memory
Public Struct dPointer
    Length As Long                              '' Length including header
    Address As Pointer                      '' The virtual address of this block, speed pointer conversion
    Type As Integer                             '' Type of memory
    Value As Pointer                            '' The actual value for usage
End Struct

'' Thi is the structure used to manage lists in shared memory
Public Struct dList                             '' A defined entry in list of objects
    Length As Long                              '' Length including header
    Address As Pointer                      '' The virtual address of this block, speed pointer conversion
    Type As Integer                             '' Type of memory
    {Next} As Pointer                          '' Next in list or head of pool
    Prev As Pointer                              '' previous in list or end of pool
    sema As Pointer                             '' The locking semephor for each list
    Global As Integer                           '' Defines if this is a global memory object or not
    bDebug As Boolean                      '' turns on or off the debug control
    Tag[64] As Byte                              '' a user text tag for this list, can be used to identify nameless queues
    RefCount As Long                          '' Number of refrences to this element
    Priority As Long                              '' in a queue this is the priority of this element
    UsePriority As Boolean                '' Enable the use of priority ordering in the list
    Value As Pointer                            '' Value of entry or count if pool
End Struct

Static Public cShmList As Integer = 20                  '' The Constant identifying this class name must not be a valid datatype integer - 20
Static Public cShmListEntry As Integer = 21        '' The entry in a ShmList object type - 21

' Extern DListPtr(dest As Pointer, src As Pointer, Len As Integer) As DList In "libc:6" Exec "memcpy"
' Extern memcpy(dest As Dlist, src As Dlist, Len As Integer) As Integer In "libc:6"

Extern sem_init(mutex As Pointer, shared As Integer, Value As Integer) As Integer In "libpthread:0"
'Extern sem_wait(mutex As Pointer) As Integer In "libpthread:0"
Extern sem_post(mutex As Pointer) As Integer In "libpthread:0"
Extern sem_getvalue(mutex As Pointer, Ivalue As Pointer) As Integer In "libpthread:0"
Extern sem_trywait(mutex As Pointer) As Integer In "libpthread:0"
Extern sem_destroy(mutex As Pointer) As Integer In "libpthread:0"
' Extern sched_yield() As Integer In "libpthread:0"

Private VirtualAddress As Pointer = 0              '' Pointer to the head of the list
Public ListHead As DList                                         '' Pointer to the actual list
Public VarMem As ShmVarStorage                    '' The storage pool to used or referenced
Public SemAddress As Pointer                             '' real pointer to the locking sem used by this list
Private Keys As NextInfo = Null                            '' Information about the last iteration

Property Read Key As Long                                   '' During iterations this will be the item count
Property Read Key_dlist As Dlist                          '' During iteration this contains the current dlist entry
Property Read Key_ExtendedId As Long           '' ExtendedId of the entry being proessed by Next
Property Read Key_Tag As String                       '' The content of the entry tag field

Property Read max As Long                                '' max count for iteration
Property Read count As Long                              '' Count of elements in this list
Property Read value As Long                              '' Returns the virtual address of this list
Property Read Type As Integer                          '' The type of this object
Property Read Address As Pointer                    '' The address of the object
Property Debug As Boolean                                '' Debugging helper
Property Read AllLists As Variant[]                   '' Returns a table of all active List{types} in memory
Property Read AllEntries As Variant[]              '' returns a list of all entries in the list
Property Tag As String                                         '' memo tag for debug and identity purposed
Property Read ClassList As String                     '' The name of the class for this list/entry
Property Read ClassEntry As String                  '' The text name of the list/queue entries
Property Read ClassMe As String                      '' the text class of the current item
Property Read Next As Variant                           '' The actual list structure entry, not the value
Property Read Prev As Variant                            '' The actual list structure entry, Not Value
Property Read First As Variant                            '' first entry in the list
Property Read Last As Variant                             '' Last entry in the list
Property Read RefCount As Variant                   '' Get number of refrences
Property Read MemoryPool As ShmVarStorage      '' Get the Memory pool this list belongs to
Property Read Global As Boolean                         '' is this list a global, ie never deleted
Property Read UsePriority As Boolean                '' If queue use priority

Public SetHeadType As Integer = cShmList             '' The list header Class
Public SetEntryType As Integer = cShmListEntry    '' The List Entry Class

Static Public Sub _init()

    ShmVarStorage.DefineClass("ShmList", cShmlist)
    ShmVarStorage.DefineClass("ShmListEntry", cShmlistEntry)

End

'' Returns a new allocated list if address is 0, else returns the exsisting list at the specified address
'' VarStorage is the pointer to the address to allocate the list from
'' VirtAddress is the address of an exsiting list, which is returned as a listObject type
'' it is also possible to pass a tag name to locate the correct list/queue
'' GlobalValue is used to allow this list to be private or a global value
'' Returns the list as a list
'' Increments the reference counter for this list
'' list may be accessed or created, VirtAddressOrTag = 0 then creat new list
''                                                                VirtAddressOrTag = "tagname" then lookfor and return list with this tag
''                                                                VirtAddressOrTag > 0 then return list at this virtual address
''                                                                 VarStorage is type stream then initialize from a stream

Public Sub _new(Optional VarStorage As Variant = Null, VirtAddressOrTag As Variant = CPointer(0), GlobalValue As Boolean = False, Tag As String = "", UsePriority As Boolean = True)

    Dim pType As Integer = TypeOf(VarStorage)
    
    If varstorage = Null Then
        Return
    Else If ptype = gb.object And If VarStorage Is Stream Then
        Dim MyValue As Variant
        MyValue = Read #VarStorage As Object
        _Configure(MyValue.MemoryPool, MyValue.Address, MyValue.Global, MyValue.tag, MyValue.UsePriority)
    Else
        _Configure(VarStorage, VirtAddressOrTag, GlobalValue, Tag, UsePriority)
    Endif

End

Public Sub _configure(Optional VarStorage As Variant = Null, VirtAddressOrTag As Variant = CPointer(0), GlobalValue As Boolean = False, Tag As String = "", UsePriority As Boolean = True)

    Dim Result As Integer = 0
    Dim VirtAddress As Pointer = 0
    Dim RealPtr As Pointer

    If Object.Class(VarStorage).name == "ShmMem" Then
        VarMem = VarStorage.MyVarMem
    Else
        VarMem = VarStorage
    Endif

    If TypeOf(VirtAddressOrTag) = gb.string Then
        VirtAddress = LocateByTag(VirtAddressOrTag)
        If VirtAddress = Null Then
            Error.Raise("List / Queue : locate by tag " & Quote(VirtAddressOrTag))
        Endif
    Else
        VirtAddress = VirtAddressOrTag
    Endif

    SetHeadType = ShmVarStorage.UserClassByName[Object.Type(Me)]
    SetEntryType = SetHeadType + 1

    If VirtAddress = 0 Then
        ListHead = NewEntry()
        VirtualAddress = ListHead.Address
        ListHead.type = SetHeadType
        ListHead.Global = GlobalValue
        ListHead.sema = VarMem.Alloc(64)
        ListHead.UsePriority = UsePriority
        ListHead.Value = 0
        ListHead.tag = Byte[].FromString(tag)
        SemAddress = varmem.RealDataAddress(ListHead.sema)
        result = sem_init(SemAddress, 1, 0)
    Else
        RealPtr = VarMem.RealAddress(VirtAddress)
        ListHead = RealPtr
        VirtualAddress = ListHead.address
        SemAddress = varmem.RealDataAddress(ListHead.sema)

        Me.lock()
        Inc ListHead.RefCount
    Endif
    Me.unlock()

End

Public Sub _write(Dest As Stream)

    Dim entries As Variant[] = Me.Allentries

    Write #Dest, VarMem.Signature As String                           '' The signature of the Shared memory we are from
    Write #Dest, ListHead.tag.ToString() As String                  '' Save the Tag for this list
    Write #Dest, ListHead.Global As Boolean
    Write #Dest, ListHead.Value As Long                                     '' for a list this is the number of entries in the list

    For Each value As ShmListEntry In entries
        Write #Dest, value.Priority As Long
        Write #Dest, Value.Tag As String
        Write #Dest, Value.Value As Variant
    Next

End

Public Sub _read(Source As Stream)

    Dim Signature As String
    Dim varinfo As ShmMem
    Dim Count As Long
    Dim sTag As String
    Dim Global As Boolean
    Dim priority As Long
    Dim Value As Variant

    Signature = Read #Source As String
    varinfo = shmMem.GetMemSegment(Signature)

    If varinfo = Null Then
        Error.Raise("ShmList: Unable to find correct ShmMem to put value into, Needed:" & Signature)
    Endif

    sTag = Read #Source As String
    global = Read #Source As Boolean
    count = Read #Source As Long

    _Configure(varinfo, 0, Global, sTag)

    For i As Integer = 1 To count
        priority = Read #Source As Long
        sTag = Read #Source As String
        Value = Read #Source As Variant
        Add(Value, priority, sTag)
    Next

End

'' Locate a list by its Tag information
'' Returns  the virtual address of the List having the specified tag
Private Sub locateByTag(tag As String) As Pointer

    Dim result As Pointer = Null

    For Each mBlock As Variant In VarMem
        If mBlock.type = SetHeadType
            If mBlock.tag == tag Then
                result = mBlock.Address
                Break
            Endif
        Endif
    Next

    Return result

    Return Null

End
' Locate an array by virtual address in the shared memory source
'' used to veryify a valid address is passed

Private Sub locateByAddress(Virt As Pointer) As Pointer

    Dim result As Pointer = Null

    For Each mBlock As Variant In VarMem
        If mBlock.type = SetHeadType
            If mBlock.Address = virt Then
                result = mBlock.Address
                Break
            Endif
        Endif
    Next

    Return result

End

'' free this list when the refcount = 0
Public Sub _free()

    Return

    'Print Application.id, "_free Begin for ";; ShmVarStorage.GetTextType(listhead.type);; "Address =";; listhead.Address
    If varmem <> Null And If Listhead <> Null Then
        '   Print Application.id, "_free Doing for ";; ShmVarStorage.GetTextType(listhead.type);; "Address =";; listhead.Address;; "RefCount =";; listhead.refcount
        Me.lock()

        If ListHead.Refcount > IIf(ListHead.global, 1, 0) Then
            Dec ListHead.RefCount
        Endif

        If Not ListHead.Global Then
            If ListHead.RefCount = 0 Then
                Keys = Null
                '          Print Application.id, "_free finish  for ";; ShmVarStorage.GetTextType(listhead.type);; "Address =";; listhead.Address
                Me.Free()
                listhead = Null
            Else
                Me.unlock()
                '         Print Application.id, "_free Keeps for ";; ShmVarStorage.GetTextType(listhead.type);; "Address =";; listhead.Address;; "Refcount =";; listhead.refcount
            Endif
        Else
            Me.unlock()
            '    Print Application.id, "_free Global for ";; ShmVarStorage.GetTextType(listhead.type);; "Address =";; listhead.Address;; "Refcount =";; listhead.refcount
        Endif

        'Else
        'Print Application.id, "_free  Failed for shmlist dlist is null error"
    Endif

    ListHead = Null
    varmem = Null

End

'' Required for each user defined class, returns the pointer to the under laying data structure
Static Public Sub UserPtr(vvarmem As ShmVarStorage, VirtAddr As Pointer) As Dlist

    If VirtAddr <= 0 Then Return Null
    Dim RealPtr As Pointer = vVarMem.RealAddress(VirtAddr)
    Return RealPtr

End

'' Convert the Virtual address to an actual list object
Static Public Sub AsObject(vvarmem As ShmVarStorage, VirtAddr As Pointer) As ShmList

    Return Object.New(vVarMem.GetTextType(cShmList), [vvarmem, VirtAddr])

End

'' Return the real address pointed to by a virtual pointer
Public Sub EntryPtr(VirtAddress As Pointer) As DList

    If VirtAddress <= 0 Then Return Null
    Dim RealPtr As Pointer = VarMem.RealAddress(VirtAddress)
    Return RealPtr

End

'' Creates a new element and assigned the value
'' does not actually place it into the list
Public Sub NewEntry(Optional Value As Variant = Null) As DList

    Dim NewVar As Pointer
    Dim Entry As Dlist
    Dim chkval As Variant
    Dim VirtAddress As Pointer
    Dim RealAddress As Pointer
    Dim iType As Integer

    If listhead <> Null And If ListHead.bDebug Then
        Print Application.id, "Create New Entry  ShmList Value =  ";; Str(Value)
    Endif

    VarMem.Lock()
    VirtAddress = VarMem.Alloc(SizeOf(dList) - SizeOf(AllocHeader))
    RealAddress = VarMem.RealAddress(VirtAddress)
    varmem.Unlock()

    entry = RealAddress

    Entry.type = SetEntryType
    Entry.value = 0
    Entry.next = 0
    Entry.prev = 0
    Entry.RefCount = 1

    If value Then
        NewVar = VarMem.set(Value)
        Entry.Value = NewVar
        iType = TypeOf(value)
    Else
        NewVar = Entry.value
        iType = 0
    Endif

    If NewVar > 0 Then
        chkval = VarMem.Getpointer(itype, newvar)
        If chkval.address <> newvar Then                                 ''' here until debugged
            Stop
        Endif
    Endif

    If listhead <> Null And If ListHead.bDebug Then Print Application.id, "Created New Entry  ShmList Element ID =  ";; Str(entry)
    Return Entry

End

''  Lock the list/queue  while processing the request
'' This is not automatic, the user must do this if required
Public Sub {lock}() As Boolean

    Dim result As Integer = -1
    Dim retrycounter As Long = 10

    If listhead = Null Then
        Error.Raise("List/Queue - invald listhead")
    Endif

    While result <> 0
        result = sem_trywait(SemAddress)
        If result <> 0 Then
            Wait 0.0001
            Dec RetryCounter
            If retryCounter < 4 Then
                If ListHead.bDebug Then Print Application.id, "ShmList Locking Race condition attempting fix ";; retryCounter
                Me.unlock()
            Endif
        Else
            Return True
        Endif
    Wend
    If ListHead.bDebug Then Print Application.id, "ShmList Locking Race condition attempt to fix failed";; retryCounter
    Return False

End

''  Release the lock on the list/queue
'' Returns false if the lock was not 0, locked
'' be careful as this can be posted anywhere

Public Sub {unlock}() As Boolean

    If listhead = Null Then
        Error.Raise("List/Queue - invald listhead")
    Endif

    Dim value As Integer = 0
    Dim iptr As Pointer = VarPtr(value)

    If sem_getvalue(SemAddress, iptr) = 0 Then
        If value = 0 Then
            sem_post(SemAddress)
            Return True
        Endif
    Endif
    Return False

End

'' Add a new value to the list, Copies the value into shared memory space
Public Sub add(Value As Variant, Optional ExtendedId As Long = 0, TagInfo As String = "")

    Dim NewElement As DList
    Dim LastEntry As Dlist
    Dim RealAddress As Pointer

    If listhead = Null Then
        Error.Raise("List/Queue - invald listhead")
    Endif

    If ListHead.bDebug Then Print Application.id, "Add ShmList Value = ";; Str(Value)
    Me.lock()

    NewElement = NewEntry(Value)
    NewElement.Priority = ExtendedId

    If TagInfo <> "" Then
        ' If TagInfo.len < NewElement.Tag.Length Then TagInfo = Left(TagInfo & Space(NewElement.Tag.Length), NewElement.Tag.Length)
        ' For i As Integer = 0 To NewElement.tag.length - 1
        '     NewElement.Tag[i] = Asc(Taginfo[i])
        ' Next
        NewElement.Tag = Byte[].FromString(Taginfo)
    Endif

    If ListHead.Next = 0 Then
        ListHead.Next = NewElement.Address
        ListHead.prev = NewElement.Address
    Else
        RealAddress = VarMem.RealAddress(ListHead.prev)
        LastEntry = RealAddress

        ListHead.Prev = NewElement.Address
        NewElement.prev = LastEntry.address
        LastEntry.Next = NewElement.Address
        NewElement.next = Null
    Endif

    Inc ListHead.Value                ' this holds the count of elements in this list

    Me.unlock()

    If ListHead.bDebug Then Print Application.id, "Add ShmList Added Value = ";; Str(value)

End

'' Assign  this list to another variable
Public Sub _Assign(VEntry As DPointer)

    If listhead = Null Then
        vEntry.value = Null                     ' if the listhead is valid then continue
    Else
        Inc ListHead.RefCount                                                         '  represents the number of refrences to this entry
        vEntry.Value = ListHead.Address                                     '  Assign this to the variable
    Endif

End

'' Free the entrie list, ignores refcount and global flags
Public Sub {Free}(Optional OverRideGlobal As Boolean = False)           '' Free the entire list

    If Varmem = Null Or If listhead = Null Then Return                                   ' if the listhead is valid then continue

    If OverRideGlobal Then ListHead.Global = False                                      ' are we overriding the global param?
    If ListHead.Global Then Return                                                                       ' if this is global then get out of here

    If ListHead.sema <> Null Then                                                                          ' Delete the semaphore
        sem_destroy(VarMem.RealDataAddress(ListHead.sema))
        VarMem.Free(ListHead.sema)                                                                     ' Release the memory pointer
        ListHead.sema = Null
    Endif

    Me.Clear()                                                                                                                 ' remove and delete all the elements in the list

    varmem.Free(listhead.address)                                                                        ' free the actual list container
    listhead = Null                                                                                                         ' mark it as destroyed

End

'' clear the content of a list, free the values and the entries
Public Sub Clear()

    Dim pEntry As Variant

    If listhead = Null Then
        Error.Raise("List/Queue  clear - invald listhead")
    Endif

    While Me.count > 0
        pentry = Me.Remove(-1, False)
    Wend

End

'' Return a simple list of all the elements in a list/queue
'' these are pointers to the actual memory, so be carefull
'' any changes
Public Sub AsDlistList() As DList[]

    If listhead = Null Then
        Error.Raise("List/Queue  asDlistList - invald listhead")
    Endif

    Dim pList As New DList[]
    Dim Source As Dlist = EntryPtr(ListHead.next)

    If source = Null Or If Source.next = Source.address Then
        Stop
        Return plist
    Endif

    While Source
        pList.Add(Source)
        Source = EntryPtr(Source.next)
    Wend

    Return plist

End

'' Free an entry from its data structure information
Private Sub FreeEntry(Entry As DList)

    If listhead = Null Then
        Error.Raise("List/Queue - invald listhead")
    Endif

    If ListHead.bDebug Then Print Application.id, "Free Entry  in ShmList :";; entry.address;; "RefCount="; entry.RefCount
    If entry.refcount > 0 Then Dec entry.refcount
    If entry.refcount = 0 Then
        VarMem.Free(entry.value)
        Varmem.Free(entry.address)
    Endif

End

'' Get the value of the entry at index position
Public Sub _get(Index As Integer) As Variant

    Dim Result As Variant
    Dim dPtr As Dlist

    If listhead = Null Then
        Error.Raise("List/Queue _get - invald listhead")
    Endif

    If ListHead.bDebug Then Print Application.id, "_get ShmList index =  " & Index
    Me.lock()

    dPtr = SeekRec(Index)

    If Dptr = Null Then
        Me.unlock()
        If ListHead.bDebug Then Print Application.id, "_get ShmList Record Not Found  returned NULL "
        Return Null
    Endif

    If ListHead.bDebug Then Print Application.id, "_get ShmList VarMem.Lock  index = " & Index & " Dptr = " & Str(dptr)
    VarMem.Lock()
    Result = VarMem[dPtr.value]
    VarMem.Unlock()
    If ListHead.bDebug Then Print Application.id, "_Get ShmList VarMem.UnLock " & Index

    Me.unlock()
    Return result

Finally
    Me.unlock()

Catch
    Error.Propagate()

End

'' Put a value into an exsisting element based upon the index
Public Sub _put(Value As Variant, Index As Integer)

    Dim dPtr As Dlist

    If listhead = Null Then
        Error.Raise("List/Queue _put  - invald listhead")
    Endif

    If ListHead.bDebug Then Print Application.id, "_put ShmList index = " & Index & " Value = " & Str(value)
    Me.lock()

    dPtr = SeekRec(Index)

    If Dptr = Null Then
        If ListHead.bDebug Then Print Application.id, "_put ShmList Index not found :" & Index
        Error.Raise("Out Of Bounds ")
    Endif

    VarMem.lock()
    VarMem[dPtr.value] = Value
    VarMem.Unlock()

    Me.unlock()
    If ListHead.bDebug Then Print Application.id, "_put ShmList Success at " & Index & "Value = " & Str(value)

Catch
    Me.unlock()
    Error.Propagate()

End

'' Insert a new value into the list at the index position, -1 means end of list
Public Sub insert(Index As Long, value As Variant, Optional ExtendedId As Integer = 0, TagInfo As String = "")

    Dim Current As Dlist
    Dim ptrPrev As DList

    If listhead = Null Then
        Error.Raise("List/Queue insert - invald listhead")
    Endif

    Dim NewItem As Dlist = NewEntry(Value)

    If ListHead.bDebug Then Print Application.id, "Insert ShmList  at index =  " & Str(Index)

    Me.lock()

    If TagInfo <> "" Then
        ' If TagInfo.len < NewItem.Tag.Length Then TagInfo = Left(TagInfo & Space(NewItem.Tag.Length), NewItem.Tag.Length)
        ' For i As Integer = 0 To NewItem.tag.length - 1
        '     NewItem.Tag[i] = Asc(Taginfo[i])
        ' Next
        NewItem.tag = Byte[].FromString(TagInfo)
    Endif

    NewItem.Priority = ExtendedId

    If Index = 0 Then
        If ListHead.Next = 0 Then
            ListHead.next = NewItem.Address
            ListHead.prev = NewItem.Address
        Else
            Current = EntryPtr(ListHead.next)
            Current.prev = NewItem.address
            NewItem.Next = Current.Address
            ListHead.Next = NewItem.address
        Endif
    Else If Index = -1 Then
        If ListHead.prev = 0 Then
            ListHead.next = NewItem.Address
            ListHead.prev = NewItem.Address
        Else
            Current = EntryPtr(ListHead.Prev)
            Current.next = NewItem.Address
            NewItem.Prev = Current.Address
            ListHead.Prev = NewItem.address
        Endif
    Else
        Current = SeekRec(Index)

        If Not Current Then
            Me.Unlock()
            If ListHead.bDebug Then Print Application.id, "Insert ShmList out of bounds index = " & Str(Index)
            Error.Raise("Out Of Bounds")
        Endif

        If Current.Address = ListHead.next Then
            Current.Prev = NewItem.Address
            ListHead.next = NewItem.Address
            NewItem.Next = Current.address
        Else
            ptrprev = EntryPtr(Current.prev)
            Current.prev = NewItem.address
            NewItem.next = Current.address
            NewItem.prev = ptrPrev.Address
            ptrPrev.Next = NewItem.address
        Endif

    Endif

    Inc ListHead.Value

    Me.Unlock()
    If ListHead.bDebug Then Print Application.id, "Insert ShmList completed for index = " & Str(Index)

Catch
    Me.unlock()
    Error.Propagate()

End

'' look for the index element and return the Element(dlist Struct)
'' containing the element entry
Private Sub SeekRec(Index As Integer) As DList

    Dim Count As Integer
    Dim Current As DList

    If listhead = Null Then
        Error.Raise("List/Queue SeekRec- invald listhead")
    Endif

    If Index < 0 Or If Index >= ListHead.Value Then
        Return Null
    Endif

    Current = EntryPtr(ListHead.next)

    While Count < Index
        Current = EntryPtr(Current.next)
        Inc Count
    Wend

    If current = Null Then
        Stop
    Endif

    Return Current

End

'' remove the current element from the list, optionally return the value of the entry
Private Sub _remove(CurrentItem As Dlist, Optional WithValue As Boolean = True) As Variant

    Dim addr As Pointer = CurrentItem.address
    Dim value As Variant
    Dim ptrprev As Dlist
    Dim ptrNext As Dlist

    If listhead = Null Then
        Error.Raise("List/Queue _remove - invald listhead")
    Endif

    If WithValue Then
        Value = VarMem[CurrentItem.value]                            ' get the value of the item being removed
    Endif

    If addr = ListHead.next Then                                          ' if this is the head of the queue
        ListHead.next = CurrentItem.Next                            ' ListHead Next should point to Whatever current item points to
        If ListHead.next = Null Then                                        ' if this was only one on list
            ListHead.prev = Null                                                  ' Previous also becomes null
            ListHead.value = 0                                                      ' Empty the queue
        Else
            ptrnext = EntryPtr(ListHead.next)                        ' check if just one item on the queue
            If ptrnext.Next = Null Then                                     ' If it is then
                ListHead.Prev = ListHead.Next                          ' it also becoms the previous item
            Endif
        Endif
    Else If addr = ListHead.prev Then                                ' if the address matches the end of the queue
        ListHead.prev = CurrentItem.prev                           ' Set the Previous to the current item previous
        PtrPrev = EntryPtr(CurrentItem.prev)                    ' get the physical address of the previous entry
        ptrPrev.next = Null                                                       ' Since we are at the end of the list just set it to null
    Else
        ptrnext = EntryPtr(currentItem.next)                     ' Well we must be in the list then Get Pysical address of next item
        ptrprev = EntryPtr(CurrentItem.prev)                    ' get the pysical address of the previous item
        ptrnext.prev = ptrprev.address                              ' Point the next items previous to current item previous
        ptrprev.next = ptrnext.address                              ' Point the previous items next to the current items next
    Endif

    If listhead.value > 0 Then Dec ListHead.value

    currentItem.Next = Null
    CurrentItem.prev = Null

    Return Value

End

'' Remove an element from the list based upon the extended id
'' Returns the value of the entry
Public Sub RemoveExtId(ExtendedId As Long) As Variant

    Dim currentItem As DList
    Dim Value As Variant

    If listhead = Null Then
        Error.Raise("List/Queue remove ext id- invald listhead")
    Endif

    If ListHead.bDebug Then Print Application.id, "RemoveExtId ShmList For " & ExtendedId
    Me.lock()

    If ListHead.next = 0 Then
        Me.unlock()
        If ListHead.bDebug Then Print Application.id, "RemoveExtId ShmList For " & ExtendedId & " Failed empty list"
        Error.Raise("Empty List - Extended ID : " & ExtendedID)
    Endif

    CurrentItem = EntryPtr(ListHead.next)

    ' search for the matching value
    While CurrentItem <> Null
        If CurrentItem.Priority = ExtendedId Then Break
        CurrentItem = EntryPtr(CurrentItem.next)
    Wend

    If CurrentItem = Null Then
        Me.Unlock()
        If ListHead.bDebug Then Print Application.id, "RemoveByExtId ShmList VarMem.UnLock " & ExtendedId
        Error.Raise("Not Found -  Extended ID : " & Value)
    Else
        If ListHead.bDebug Then Print Application.id, "RemoveExtId ShmList For " & ExtendedId & " Found"
    Endif

    value = _remove(CurrentItem)

    Me.unlock()

    If ListHead.bDebug Then Print Application.id, "RemoveExtId ShmList VarMem.UnLock " & ExtendedId

    FreeEntry(CurrentItem)

    Return value

Finally
    Me.unlock()

Catch
    Dim myerror As String = Error.text & Error.where
    Error.Raise(myerror)

End

'' Remove an element from the list based upon the tag
'' Returns the value of the entry
Public Sub RemoveTag(sTag As String) As Variant

    Dim currentItem As DList
    Dim Value As Variant

    If listhead = Null Then
        Error.Raise("List/Queue remove Tag - invalid listhead")
    Endif

    If ListHead.bDebug Then Print Application.id, "RemoveTag ShmList For " & sTag
    Me.lock()

    If ListHead.next = 0 Then
        Me.unlock()
        If ListHead.bDebug Then Print Application.id, "RemoveTag ShmList For " & sTag & " Failed empty list"
        Error.Raise("Empty List - Tag : " & sTag)
    Endif

    CurrentItem = EntryPtr(ListHead.next)

    ' search for the matching value
    While CurrentItem <> Null
        If CurrentItem.Tag == stag Then Break
        CurrentItem = EntryPtr(CurrentItem.next)
    Wend

    If CurrentItem = Null Then
        Me.Unlock()
        If ListHead.bDebug Then Print Application.id, "RemoveByTag ShmList VarMem.UnLock " & sTag
        Error.Raise("Not Found -  sTag : " & sTag)
    Else
        If ListHead.bDebug Then Print Application.id, "RemoveTag ShmList For " & sTag & " Found"
    Endif

    value = _remove(CurrentItem)

    Me.unlock()

    If ListHead.bDebug Then Print Application.id, "RemoveTag ShmList VarMem.UnLock " & sTag

    FreeEntry(CurrentItem)

    Return value

Finally
    Me.unlock()

Catch
    Dim myerror As String = Error.text & Error.where
    Error.Raise(myerror)

End

'' Pop the next entry, but return all the fields from the entry
'' Including the value
Public Sub PopInfo() As EntryInfo

    Dim result As EntryInfo

    If listhead = Null Then
        Error.Raise("List/Queue PopInfo - invald listhead")
    Endif

    If listhead.value = 0 Then Error.Raise("PopInfo : empty queue")
    Dim all As DList = EntryPtr(listhead.prev)
    result = New EntryInfo(Pop(), all.Priority, all.Tag.ToString())
    Return result

End

'' Remove the last item in the list and return the value
Public Sub Pop() As Variant

    If listhead = Null Then
        Error.Raise("List/Queue pop - invald listhead")
    Endif

    If ListHead.value > 0 Then
        Return Remove(-1)
    Else
        Error.Raise("Pop : empty queue")
    Endif

End

'' Push a value onto the end of the queue
Public Sub Push(value As Variant, Optional ExtendedID As Long = 0, TagInfo As String = "Push")

    If listhead = Null Then
        Error.Raise("List/Queue push - invald listhead")
    Endif
    add(value, ExtendedID, TagInfo)

End

'' Remove element by index value, or the last element by default
'' Returns the value of the element
Public Sub remove(Optional Index As Long = -1, WithReturn As Boolean = True) As Variant

    Dim currentItem As DList
    Dim Count As Long = 0
    Dim Value As Variant

    If listhead = Null Then
        Error.Raise("List/Queue remove - invald listhead")
    Endif

    Me.lock()
    If ListHead.bDebug Then
        Print Application.id, "Remove ShmList Item " & Index
    Endif

    If ListHead.next = Null Or Index >= CLong(ListHead.value) Then
        Me.unlock()
        If ListHead.bDebug Then Print Application.id, "Remove ShmList Item failed out of bounds " & Index
        Error.Raise("Out Of Bounds - remove Index : " & Index)
    Endif

    If Index = 0 Then
        CurrentItem = EntryPtr(ListHead.next)
    Else If Index = -1 Then
        CurrentItem = EntryPtr(ListHead.prev)
    Else
        If index < 0 Then index = CLong(listhead.value) + index
        If index < 0 Then
            Me.unlock()
            If ListHead.bDebug Then Print Application.id, "Remove ShmList Item failed out of bounds " & Index
            Error.Raise("Out Of Bounds - remove Index : " & Index)
        Endif

        CurrentItem = EntryPtr(ListHead.next)

        While Count < Index
            CurrentItem = EntryPtr(CurrentItem.next)
            If CurrentItem = Null Then Break
            Inc count
        Wend

    Endif

    If CurrentItem = Null Then
        Me.unlock()
        Error.Raise("Out of Bounds - Remove by index : " & index)
    Endif

    value = _remove(CurrentItem, WithReturn)

    Me.unlock()

    If ListHead.bDebug Then Print Application.id, "Remove ShmList VarMem.UnLock " & Index & " Value=" & value

    FreeEntry(CurrentItem)

    Return Value

Finally
    Me.unlock()

Catch
    Print Error.text, Error.Where
    Stop
    Error.Propagate()

End

''  Remove an element by its value as the key
''  returns the value of the element
Public Sub RemoveByValue(vValue As Variant) As Variant

    Dim currentItem As DList
    Dim Value As Variant

    If listhead = Null Then
        Error.Raise("List/Queue remove by value- invald listhead")
    Endif

    If ListHead.bDebug Then Print Application.id, "RemoveByValue ShmList  " & Str(vValue)
    Me.lock()

    If ListHead.next = 0 Then
        If ListHead.bDebug Then Print Application.id, "RemoveByValue ShmList  not found " & Str(vValue)
        Error.Raise("Empty List - Value Not Found : " & Str(vValue))
    Endif

    CurrentItem = EntryPtr(ListHead.next)
    If CurrentItem.Address = ListHead.Address Then
        Stop
    Endif

    While CurrentItem <> Null
        Value = VarMem[CurrentItem.value]                            ' get the value of the item being removed
        If Value = vValue Then Break
        CurrentItem = EntryPtr(CurrentItem.next)
    Wend

    If Not CurrentItem Then
        Print Application.id, "RemoveByValue ShmList Not found  " & Str(vValue)
        Error.Raise("Not Found - Value : " & Str(vValue))
    Endif

    Value = _remove(CurrentItem)

    Me.unlock()

    If ListHead.bDebug Then Print Application.id, "RemoveByValue ShmList  Found  " & Str(vValue)

    FreeEntry(CurrentItem)

    Return value

Finally
    Me.unlock()

Catch
    Error.Propagate()

End

'' Remove an element by its virtual address as the key
'' returns the value of the element
Public Sub RemoveByVirt(VirtAddress As Pointer) As Variant

    Dim currentItem As DList

    If listhead = Null Then
        Error.Raise("List/Queue remove by virtual address - invald listhead")
    Endif
    If ListHead.bDebug Then Print Application.id, "RemoveByVirt ShmList  " & VirtAddress
    Me.lock()

    If ListHead.next = 0 Then
        If ListHead.bDebug Then Print Application.id, "RemoveByVirt ShmList  not found " & VirtAddress
        Error.Raise("Empty List - Virtual Address Not Found : " & VirtAddress)
    Endif

    Dim Value As Variant

    CurrentItem = EntryPtr(ListHead.next)

    CurrentItem = EntryPtr(ListHead.next)
    If CurrentItem.Address = ListHead.Address Then
        Stop
    Endif

    While CurrentItem <> Null
        If CurrentItem.address = VirtAddress Then Break
        CurrentItem = EntryPtr(CurrentItem.next)
    Wend

    If Not CurrentItem Then
        Print Application.id, "RemoveByVirt ShmList Not found  " & VirtAddress
        Error.Raise("Not Found - Virtual Address : " & VirtAddress)
    Endif

    Value = _remove(CurrentItem)
    Me.unlock()

    If ListHead.bDebug Then Print Application.id, "RemoveByVirt ShmList  Found  " & VirtAddress

    FreeEntry(CurrentItem)

    Return value

Finally
    Me.unlock()

Catch
    Error.Propagate()

End

'' Create a deep copy of the list
Public Sub {Copy}() As Variant

    Dim newlist As Variant
    Dim NewExtendedID As Long
    Dim NewTag As String

    If listhead = Null Then
        Error.Raise("List/Queue copy - invald listhead")
    Endif

    newlist = Object.Class(Me).New([VarMem, 0, Me.ListHead.Global, "Copy:" & Me.tag])

    Me.lock()
    For Each v As Variant In Me                         'Move the values To the New List
        NewExtendedId = Me.Key_ExtendedId
        NewTag = Me.Key_Tag
        newlist.add(v, NewExtendedID, NewTag)
    Next
    Me.unlock()

    Return newlist

Finally
    Me.unlock()

Catch
    Error.Propagate

End

'' Returns index of current item in for next
Private Function key_read() As Long

    If listhead = Null Or If keys = Null Then Return -1
    Return keys.counter

End

'' Returns the Tag of the current item in for next
Private Function Key_Tag_read() As String

    If listhead = Null Or If keys = Null Then Return ""
    Return keys.Elements[keys.counter].tag

End

'' Returns the dListentry  pointer of the current item in for next
Private Function Key_dlist_read() As Dlist

    If listhead = Null Or If keys = Null Then Return Null
    Return keys.Elements[keys.counter].dlist

End

'' Returns the extended Id or Priority of the current Item in a for next
Private Function Key_ExtendedId_read() As Long

    If listhead = Null Or If keys = Null Then Return -1
    Return keys.Elements[keys.counter].Priority

End

'' Iteration throught the list
Public Sub _next() As Variant

    Dim enumEntry As NextInfo

    If IsNull(Enum.Index) Then

        If listhead <> Null Then
            enumentry = New NextInfo(_allEntries())
            If enumentry.Elements.Count = 0 Then
                keys = Null
                Enum.Stop()
                Return
            Endif
            Enum.Index = enumentry
        Else
            keys = Null
            Enum.Stop()
            Return
        Endif
    Else
        Inc Enum.Index.counter
        If Enum.Index.counter = Enum.Index.elements.count Then
            keys = Null
            Enum.Stop()
            Return
        Endif
    Endif

    keys = Enum.index
    Return keys.elements[keys.Counter].Value

Catch
    Error.Propagate()

End

'' Finds the element with the extended id
'' Returns the index if it is found
'' Returns -1 if not found
Public Sub FindExtId(Value As Long, Optional returnElement As Boolean = False) As Variant

    Dim Count As Long = 0
    Dim Result As Long = -1

    If listhead = Null Then
        Error.Raise("List/Queue Find extended id - invald listhead")
    Endif

    If listhead.bDebug Then Print Application.id, "FindExtId : ";; Object.Class(Me).name;; "Entries=";; Me.count

    For Each dd As Variant In Me

        If Me.key_dlist = Null Then
            Break
        Endif

        If Me.Key_dlist.Priority = value Then
            Result = count
            Break
        Endif

        Inc count
    Next

    If listhead.bDebug Then Print Application.id, "FindExtId : checked ";; Me.count + 1;; "entries, index="; result
    If ReturnElement Then
        If result = -1 Then
            Return Null
        Else
            Return Object.New(VarMem.GetTextType(Me.key_dlist.Type), [varmem, Me.key_dlist.address])
        Endif
    Else
        Return result
    Endif

Catch
    Error.Propagate()

End

'' Finds the element with the tag
'' Returns the index if it is found
'' Returns -1 if not found
Public Sub FindTag(Value As String, Optional returnElement As Boolean = False) As Variant

    Dim Count As Long = 0
    Dim Result As Long = -1

    If listhead = Null Then
        Error.Raise("List/Queue Find extended id - invald listhead")
    Endif

    If listhead.bDebug Then Print Application.id, "FindExtId : ";; Object.Class(Me).name;; "Entries=";; Me.count

    For Each dd As Variant In Me

        If Me.key_dlist = Null Then
            Break
        Endif

        If Me.Key_dlist.Tag.ToString == value Then
            Result = count
            Break
        Endif

        Inc count
    Next

    If listhead.bDebug Then Print Application.id, "FindExtId : checked ";; Me.count + 1;; "entries, index="; result
    If ReturnElement Then
        If result = -1 Then
            Return Null
        Else
            Return Object.New(VarMem.GetTextType(Me.key_dlist.Type), [varmem, Me.key_dlist.address])
        Endif
    Else
        Return result
    Endif

Catch
    Error.Propagate()

End

'' Finds the element with the Virtual Address
'' Returns the index if it is found
'' Returns -1 if not found
Public Sub FindVirtAddress(VirtAddress As Pointer, Optional ReturnElement As Boolean = False) As Variant

    Dim Count As Long = 0
    Dim result As Long = -1

    If listhead = Null Then
        Error.Raise("List/Queue Find Virtual address - invald listhead")
    Endif

    If listhead.bDebug Then Print " FindVirtAddress : ";; Object.Class(Me).name;; "Entries=";; Me.count

    For Each dd As Variant In Me
        If Me.key_dlist = Null Then Break
        If Me.key_dlist.Address = VirtAddress Then
            result = count
            Break
        Endif
        Inc count
    Next

    If listhead.bDebug Then Print "FindVirtAddress : checked ";; Me.count + 1;; "entries, index="; result
    If ReturnElement Then
        If result = -1 Then
            Return Null
        Else
            Return Object.New(VarMem.GetTextType(Me.key_dlist.Type), [varmem, Me.key_dlist.address])
        Endif
    Else
        Return result
    Endif

Catch
    Error.Propagate()

End

'' Check if a specified value is stored in the list
'' returns the index if it is found -1 if it is not
Public Sub Find(value As Variant, Optional ReturnElement As Boolean = False) As Variant

    Dim count As Long = 0
    Dim Result As Long = -1

    If listhead = Null Then
        Error.Raise("List/Queue Find - invald listhead")
    Endif

    If listhead.bDebug Then Print " Find Value : ";; Object.Class(Me).name;; "Entries=";; Me.count

    For Each dd As Variant In Me
        If Me.key_dlist = Null Then Break
        If VarMem[Me.Key_dlist.Value] = value Then
            result = count
            Break
        Endif
        Inc count
    Next

    If listhead.bDebug Then Print "Find Value : checked ";; Me.count + 1;; "entries, index="; result
    If ReturnElement Then
        If result = -1 Then
            Return Null
        Else
            Return Object.New(VarMem.GetTextType(Me.key_dlist.Type), [varmem, Me.key_dlist.address])
        Endif
    Else
        Return result
    Endif
Catch
    Error.Propagate()

End

'' Returns the last element address in the list
Private Function max_Read() As Long

    If ListHead = Null Then Return 0
    Return ListHead.Value - 1

End

'' Returns the number of entries in the list
Private Function count_Read() As Long

    If ListHead = Null Then Return 0
    Return ListHead.Value

End

'' Returns the Virtual Address of the list
Private Function value_Read() As Long

    If ListHead = Null Then Return 0
    Return VirtualAddress

End

'' returns the Type of list as an integer ID
Private Function Type_Read() As Integer

    If ListHead = Null Then Return 0
    Return SetHeadType

End

'' Returns the virtual address of list
Private Function Address_Read() As Pointer

    If ListHead = Null Then Return 0
    Return VirtualAddress

End

'' returns the Debug flag. when set debug info is printed
Private Function Debug_Read() As Boolean

    If ListHead = Null Then Return False
    Return ListHead.bDebug

End

'' Sets or resets the Debug flag
Private Sub Debug_Write(Value As Boolean)

    Print "Set debug to ";; value
    If ListHead = Null Then Return
    ListHead.bDebug = Value

End

'' Returns a list Of all the objects Of the same type As This Class
'' from the shared memory
Private Function AllLists_Read() As Variant[]

    Return ShmMem.GetListType(varmem, SetHeadType)

End

'' returns an array of elements for all list type classes
'' Entries in this list point to the underlaying shared values
'' if you change anything in this list it will affect every other
'' refrence to this list
Private Function AllEntries_read() As Variant[]

    Return _allEntries()

End

'' returns an array of list entry objects
Function _allEntries() As Variant[]

    Dim nextitem As Dlist
    Dim items As New Variant[]
    Dim newObject As Object

    If varmem = Null Or If listhead = Null Then Return items

    Me.lock()
    nextitem = EntryPtr(listhead.Next)
    While nextitem <> Null
        newObject = Object.New(VarMem.GetTextType(nextitem.Type), [varmem, nextitem.address])
        items.Add(newObject)
        nextitem = EntryPtr(NextItem.Next)
    Wend
    Me.unlock()

    Return items

Finally
    Me.unlock()

Catch
    Error.Propagate()

End

'' returns the Tag associated with this list
Private Function Tag_Read() As String

    If ListHead = Null Then Return ""
    Return ListHead.Tag.ToString()

End

'' Set /change the tag associated with this list
Private Sub Tag_Write(Value As String)

    If ListHead = Null Then Return
    listhead.tag = Byte[].FromString(value)

End

'' Create a text representation of this list in tree format
Public Sub textTree() As String

    Dim result As String = ""
    Dim Indent As String = "    "
    Dim entry As Variant

    If varmem = Null Or If listhead = Null Then Return "Invalid list "

    Result = "Tree for : " & Me.tag & " Total Entries " & Me.count & "\n"
    For Each entry In Me
        Result &= Subst("&1&2 &3 &4 \t\t&5\n", indent, Me.key, Me.Key_Tag, Me.Key_ExtendedId, ShmVarStorage.GetTextType(Me.key_dlist.Type))
    Next

    Return result

End

'cShmList As Integer = 20                  '' The Constant identifying this class name must not be a valid datatype integer
'cShmListEntry As Integer = 21        '' The entry in a ShmList object type
'' return the text name of the list/queue being accessed
Private Function ClassList_Read() As String

    Return varmem.GetTextType(ListHead.Type)

End

'' return the TextName of the class used for entries in this list
Private Function ClassEntry_Read() As String

    Return varmem.GetTextType(Me.SetEntryType)

End

'' Redundant, gets text name of the class for the list object
Private Function ClassMe_Read() As String

    If varmem = Null Or If listhead = Null Then Return "Invalid list"
    Return varmem.GetTextType(ListHead.Type)

End

'' Returns the next entry in the list, based on the current entry
Private Function Next_Read() As Variant

    If Listhead <> Null And If listhead.Next <> Null Then
        Dim nextitem As Dlist = EntryPtr(listhead.Next)
        Return object.new(VarMem.GetTextType(nextitem.type), [varmem, nextitem.Address])
    Endif

    Return Null

End

'' Returns the Previous entry based upon the current entry
Private Function Prev_Read() As Variant

    If Listhead <> Null And If listhead.prev <> Null Then
        Dim previtem As Dlist = EntryPtr(listhead.prev)
        Return object.new(VarMem.GetTextType(previtem.type), [varmem, previtem.Address])
    Endif

    Return Null

End

'' Returns the value of the first entry on the list
Private Function First_Read() As Variant

    Dim value As Variant = Null

    If Listhead <> Null And If listhead.next <> Null Then
        Dim CurrentItem As Dlist = EntryPtr(listhead.next)
        Value = VarMem[CurrentItem.value]
    Endif

    Return value

End

'' returns the value of the last entry in the list
Private Function Last_Read() As Variant

    Dim value As Variant = Null

    If Listhead <> Null And If listhead.prev <> Null Then
        Dim CurrentItem As Dlist = EntryPtr(listhead.prev)
        Value = VarMem[CurrentItem.value]
    Endif

    Return value

End

'' returns the refrence count of this list
Private Function RefCount_Read() As Variant

    If varmem = Null Or If listhead = Null Then Return 0
    Return ListHead.RefCount

End

Private Function MemoryPool_Read() As ShmVarStorage

    Return VarMem

End

Private Function Global_Read() As Boolean

    Return ListHead.Global

End

Private Function UsePriority_Read() As Boolean

    Return ListHead.UsePriority

End
