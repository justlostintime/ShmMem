' Gambas class file

' Author Westwood JustLostintime
'Released Under:
'  GNU GENERAL Public LICENSE
'  Version 3, 29 June 2007
'  See project license file.

Export
'Fast Unsafe

''' Defines the Shm datatype - list
''' Lists are inherited by every other list based object

Public Struct AllocHeader              '' Standard header
    Length As Long                              '' Length including header
    Address As Pointer                      '' The virtual address of this block, speed pointer conversion
    Type As Integer                             '' Type of memory
    {Next} As Pointer                          '' null if no more in list
End Struct

Public Struct dPointer
    Length As Long                              '' Length including header
    Address As Pointer                      '' The virtual address of this block, speed pointer conversion
    Type As Integer                             '' Type of memory
    Value As Pointer                            '' The actual value for usage
End Struct

Public Struct dList                             '' A defined entry in list of objects
    Length As Long                              '' Length including header
    Address As Pointer                      '' The virtual address of this block, speed pointer conversion
    Type As Integer                             '' Type of memory
    {Next} As Pointer                          '' Next in list or head of pool
    Prev As Pointer                              '' previous in list or end of pool
    sema As Pointer                             '' The locking semephor for each list
    Global As Integer                           '' Defines if this is a global memory object or not
    bDebug As Boolean                      '' turns on or off the debug control
    Tag[16] As Byte                              '' a user text tag for this list, can be used to identify nameless queues
    RefCount As Long                          '' Number of refrences to this element
    Priority As Long                              '' in a queue this is the priority of this element
    UsePriority As Boolean                '' Enable the use of priority ordering in the list
    enum_counter As Long               '' Used when enumerating a list structure
    enum_listitem As Dlist                 '' pointer to dlist
    Value As Pointer                            '' Value of entry or count if pool
End Struct

Static Public cShmList As Integer = 20                  '' The Constant identifying this class name must not be a valid datatype integer
Static Public cShmListEntry As Integer = 21        '' The entry in a ShmList object type

' Extern DListPtr(dest As Pointer, src As Pointer, Len As Integer) As DList In "libc:6" Exec "memcpy"
' Extern memcpy(dest As Dlist, src As Dlist, Len As Integer) As Integer In "libc:6"

Extern sem_init(mutex As Pointer, shared As Integer, Value As Integer) As Integer In "libpthread:0"
Extern sem_wait(mutex As Pointer) As Integer In "libpthread:0"
Extern sem_post(mutex As Pointer) As Integer In "libpthread:0"
Extern sem_getvalue(mutex As Pointer, Ivalue As Pointer) As Integer In "libpthread:0"
' Extern sem_trywait(mutex As Pointer) As Integer In "libpthread:0"
Extern sem_destroy(mutex As Pointer) As Integer In "libpthread:0"
' Extern sched_yield() As Integer In "libpthread:0"

Private VirtualAddress As Pointer = 0              '' Pointer to the head of the list
Public ListHead As DList                                         '' Pointer to the actual list
Public VarMem As ShmVarStorage                    '' The storage pool to used or referenced
Public SemAddress As Pointer                             '' real pointer to the locking sem used by this list
Property Read Key As Long                                   '' During iterations this will be the item count
Property Read Key_dlist As Dlist                          '' During iteration this contains the current dlist entry
Property Read Key_ExtendedId As Long           '' ExtendedId of the entry being proessed by Next
Property Read Key_Tag As String                       '' The content of the entry tag field

Property Read max As Long                                '' max count for iteration
Property Read count As Long                             '' Count of elements in this list
Property Read value As Long                             '' Returns the virtual address of this list
Property Read Type As Integer                        '' The type of this object
Property Read Address As Pointer                  '' The address of the object
Property Debug As Boolean                              '' Debugging helper
Property Read AllLists As Variant[]                 '' Returns a table of all active List{types} in memory
Property Read AllEntries As Variant[]             '' returns a list of all entries in the list
Property Tag As String                                        '' memo tag for debug and identity purposed
Property Read ClassList As String                    '' The name of the class for this list/entry
Property Read ClassEntry As String                 '' The text name of the list/queue entries
Property Read ClassMe As String                     '' the text class of the current item

Public SetHeadType As Integer = cShmList             '' The list header Class
Public SetEntryType As Integer = cShmListEntry    '' The List Entry Class

Static Public Sub _init()

    ShmVarStorage.DefineClass("ShmList", cShmlist)
    ShmVarStorage.DefineClass("ShmListEntry", cShmlistEntry)

End

'' Returns a new allocated list if address is 0, else returns the exsisting list at the specified address
'' VarStorage is the pointer to the address to allocate the list from
'' VirtAddress is the address of an exsiting list, which is returned as a listObject type
'' GlobalValue is used to allow this list to be private or a global value
'' Returns the list as a list
'' Increments the refrence counter for this list

Public Sub _new(VarStorage As Variant, Optional VirtAddress As Pointer = 0, GlobalValue As Boolean = False, Tag As String = "")

    If Object.Class(VarStorage).name == "ShmMem" Then
        VarMem = VarStorage.MyVarMem
    Else
        VarMem = VarStorage
    Endif

    Dim RealPtr As Pointer
    If VirtAddress = 0 Then
        ListHead = NewEntry()
        VirtualAddress = ListHead.Address
        ListHead.type = SetHeadType
        ListHead.Global = GlobalValue
        ListHead.sema = VarMem.Alloc(64)
        ListHead.UsePriority = False
        ListHead.Value = 0
        ListHead.tag = Byte[].FromString(tag)
        SemAddress = varmem.RealDataAddress(ListHead.sema)
        sem_init(SemAddress, 1, 0)
    Else
        VirtualAddress = VirtAddress
        RealPtr = VarMem.RealAddress(VirtAddress)
        ListHead = RealPtr
        ListHead.type = SetHeadType
        SemAddress = varmem.RealDataAddress(ListHead.sema)
    Endif

    Inc ListHead.RefCount

End

Public Sub _Free(Optional OverRideGlobal As Boolean = False)

    If Listhead = Null Then Return
    If OverRideGlobal Then ListHead.Global = False

    Dec ListHead.RefCount
    If ListHead.Global Then Return    '' dont delete global used lists

    If ListHead.RefCount <= 0 Then
        ' sem_destroy(varmem.RealDataAddress(ListHead.sema))
        ' varmem.Free(ListHead.sema)
        ListHead.enum_listitem = Null
        Me.Free()
    Endif

End

'' Required for each user defined class, returns the pointer to the under laying data structure
Static Public Sub UserPtr(vvarmem As ShmVarStorage, VirtAddr As Pointer) As Dlist

    If VirtAddr <= 0 Then Return Null
    Dim RealPtr As Pointer = vVarMem.RealAddress(VirtAddr)
    Return RealPtr

End

Public Sub EntryPtr(VirtAddress As Pointer) As DList

    If VirtAddress <= 0 Then Return Null
    Dim RealPtr As Pointer = VarMem.RealAddress(VirtAddress)
    ' Return DListPtr(RealPtr, RealPtr, 0)
    Return RealPtr

End

Public Sub NewEntry(Optional Value As Variant = Null) As DList

    Dim NewVar As Pointer
    Dim Entry As Dlist
    Dim chkval As Variant
    Dim VirtAddress As Pointer
    Dim RealAddress As Pointer
    Dim iType As Integer

    VirtAddress = VarMem.Alloc(SizeOf(dList) - SizeOf(AllocHeader))
    RealAddress = VarMem.RealAddress(VirtAddress)

    ' Entry = DListPtr(RealAddress, RealAddress, 0)
    entry = RealAddress

    Entry.type = SetEntryType
    Entry.value = 0
    Entry.next = 0
    Entry.prev = 0
    Entry.RefCount = 0

    If value Then
        NewVar = VarMem.set(Value)
        Entry.Value = NewVar
        iType = TypeOf(value)
    Else
        NewVar = Entry.value
        iType = 0
    Endif

    If NewVar > 0 Then
        chkval = VarMem.Getpointer(itype, newvar)
        If chkval.address <> newvar Then                                 ''' here until debugged
            Stop
        Endif
    Endif
    Return Entry

End

''  Lock the list/queue  while processing the request
'' This is not automatic, the user must do this if required
Public Sub {lock}() As Boolean

    Dim result As Integer

    result = sem_wait(SemAddress)
    Return True

End

''  Release the lock on the list/queue
'' Returns false if the lock was not 0, locked
'' be careful as this can be posted anywhere
Public Sub {unlock}() As Boolean

    Dim value As Integer

    If sem_getvalue(SemAddress, VarPtr(value)) = 0 Then
        If value = 0 Then
            sem_post(listhead.sema)
            Return True
        Endif
    Endif
    Return False

End

Public Sub add(Value As Variant, Optional ExtendedId As Long = 0, TagInfo As String = "")

    Dim NewElement As DList
    Dim LastEntry As Dlist
    Dim RealAddress As Pointer

    NewElement = NewEntry(Value)
    NewElement.Priority = ExtendedId

    If TagInfo <> "" Then
        If TagInfo.len < NewElement.Tag.Length Then TagInfo = Left(TagInfo & Space(NewElement.Tag.Length), NewElement.Tag.Length)
        For i As Integer = 0 To NewElement.tag.length - 1
            NewElement.Tag[i] = Asc(Taginfo[i])
        Next
    Endif

    If ListHead.bDebug Then Print Application.id, "Add ShmList VarMem.Lock ";; Value
    VarMem.Lock()

    If ListHead.Next = 0 Then
        ListHead.Next = NewElement.Address
        ListHead.prev = NewElement.Address
    Else
        RealAddress = VarMem.RealAddress(ListHead.prev)
        ' LastEntry = DListPtr(RealAddress, RealAddress, 0)
        LastEntry = RealAddress

        ListHead.Prev = NewElement.Address
        NewElement.prev = LastEntry.address
        LastEntry.Next = NewElement.Address
        NewElement.next = Null
    Endif

    Inc ListHead.Value                ' this holds the count of elements in this list

    VarMem.UnLock()
    If ListHead.bDebug Then Print Application.id, "Add ShmList VarMem.UnLock ";; value

End

Public Sub _Assign(VEntry As DPointer)

    Inc ListHead.RefCount                                   '  represents the number of refrences to this entry
    vEntry.Value = ListHead.Address              ' Assign this to the variable

End

Public Sub {free}()                             '' Free the entire list

    Dim pList As DList[] = AsDListList()

    sem_destroy(VarMem.RealDataAddress(ListHead.sema))
    VarMem.Free(ListHead.sema)
    varmem.Free(VirtualAddress)

    For Each pEntry As DList In pList
        FreeEntry(pEntry)
    Next

End

Public Sub Clear()

    Dim pList As DList[] = AsDListList()

    For Each pEntry As DList In pList
        FreeEntry(pEntry)
    Next

    ListHead.value = 0

End

Public Sub AsDlistList() As DList[]

    Dim pList As New DList[]
    Dim Source As Dlist = EntryPtr(ListHead.next)

    While Source
        pList.Add(Source)
        Source = EntryPtr(Source.next)
    Wend

    Return plist

End

Private Sub FreeEntry(Entry As DList)

    VarMem.Free(Entry.value)                        '' entry will always point to something
    VarMem.Free(entry.address)                   '' Dispose of this item as well

End

Public Sub _get(Index As Integer) As Variant

    Dim Result As Variant
    Dim dPtr As Dlist

    dPtr = SeekRec(Index)
    If Dptr = Null Then
        Return Null
    Endif

    If ListHead.bDebug Then Print Application.id, "_get ShmList VarMem.Lock " & Index
    VarMem.Lock()
    Result = VarMem[dPtr.value]
    VarMem.Unlock()
    If ListHead.bDebug Then Print Application.id, "_Get ShmList VarMem.UnLock " & Index
    Return result

End

Public Sub _put(Value As Variant, Index As Integer)

    Dim dPtr As Dlist

    dPtr = SeekRec(Index)
    If Dptr = Null Then
        Error.Raise("Out Of Bounds ")
    Endif

    If ListHead.bDebug Then Print Application.id, "_put ShmList VarMem.Lock " & Index
    VarMem.Lock()
    VarMem[dPtr.value] = Value
    VarMem.Unlock()
    If ListHead.bDebug Then Print Application.id, "_put ShmList VarMem.UnLock " & Index

End

Public Sub insert(Index As Long, value As Variant, Optional ExtendedId As Integer = 0, TagInfo As String = "")

    Dim Current As Dlist
    Dim ptrPrev As DList
    Dim NewItem As Dlist = NewEntry(Value)

    If TagInfo <> "" Then
        If TagInfo.len < NewItem.Tag.Length Then TagInfo = Left(TagInfo & Space(NewItem.Tag.Length), NewItem.Tag.Length)
        For i As Integer = 0 To NewItem.tag.length - 1
            NewItem.Tag[i] = Asc(Taginfo[i])
        Next
    Endif

    NewItem.Priority = ExtendedId

    If ListHead.bDebug Then Print Application.id, "Insert ShmList VarMem.Lock " & Index
    VarMem.Lock()
    If Index = 0 Then
        If ListHead.Next = 0 Then
            ListHead.next = NewItem.Address
            ListHead.prev = NewItem.Address
        Else
            Current = EntryPtr(ListHead.next)
            Current.prev = NewItem.address
            NewItem.Next = Current.Address
            ListHead.Next = NewItem.address
        Endif
    Else If Index = -1 Then
        If ListHead.prev = 0 Then
            ListHead.next = NewItem.Address
            ListHead.prev = NewItem.Address
        Else
            Current = EntryPtr(ListHead.Prev)
            Current.next = NewItem.Address
            NewItem.Prev = Current.Address
            ListHead.Prev = NewItem.address
        Endif
    Else
        Current = SeekRec(Index)
        If Not Current Then
            VarMem.Unlock()
            Error.Raise("Out Of Bounds")
        Endif

        If Current.Address = ListHead.next Then
            Current.Prev = NewItem.Address
            ListHead.next = NewItem.Address
            NewItem.Next = Current.address
        Else
            ptrprev = EntryPtr(Current.prev)
            Current.prev = NewItem.address
            NewItem.next = Current.address
            NewItem.prev = ptrPrev.Address
            ptrPrev.Next = NewItem.address
        Endif

    Endif

    Inc ListHead.Value

    VarMem.Unlock()
    If ListHead.bDebug Then Print Application.id, "Insert ShmList VarMem.UnLock " & Index

End

Private Sub SeekRec(Index As Integer) As DList

    Dim Count As Integer
    Dim Current As DList

    If Index < 0 Or If Index >= ListHead.Value Then
        Return Null
    Endif

    Current = EntryPtr(ListHead.next)

    While Count < Index
        Current = EntryPtr(Current.next)
        Inc Count
    Wend

    If current = Null Then
        Stop
    Endif
    Return Current

End

Private Sub _remove(CurrentItem As Dlist) As Variant

    Dim addr As Pointer = CurrentItem.address
    Dim value As Variant
    Dim ptrprev As Dlist
    Dim ptrNext As Dlist

    Value = VarMem[CurrentItem.value]                            ' get the value of the item being removed

    If addr = ListHead.next Then
        ListHead.next = CurrentItem.Next
        If CurrentItem.next = 0 Then
            ListHead.prev = 0
        Endif
    Else If addr = ListHead.prev Then
        ListHead.prev = CurrentItem.prev
        PtrPrev = EntryPtr(CurrentItem.prev)
        ptrPrev.next = 0
    Else
        ptrnext = EntryPtr(currentItem.next)
        ptrprev = EntryPtr(CurrentItem.prev)
        ptrnext.prev = ptrprev.address
        ptrprev.next = ptrnext.address
    Endif

    Dec ListHead.value

    Return Value

End

'' Remove an element from the list based upon the extended id
'' Returns the value of the entry
Public Sub RemoveExtId(ExtendedId As Long) As Variant

    Dim currentItem As DList
    Dim Value As Variant

    If ListHead.next = 0 Then
        Error.Raise("Empty List - Extended ID : " & value)
    Endif

    If ListHead.bDebug Then Print Application.id, "RemoveExtId ShmList VarMem.Lock " & ExtendedId
    varmem.Lock()

    CurrentItem = EntryPtr(ListHead.next)

    ' search for the matching value
    While CurrentItem <> Null And CurrentItem.Priority <> ExtendedId
        CurrentItem = EntryPtr(CurrentItem.next)
    Wend

    If Not CurrentItem Then
        varmem.Unlock()
        If ListHead.bDebug Then Print Application.id, "RemoveByExtId ShmList VarMem.UnLock " & ExtendedId
        Error.Raise("Not Found -  Extended ID : " & Value)
    Endif

    value = _remove(CurrentItem)

    varmem.Unlock()
    If ListHead.bDebug Then Print Application.id, "RemoveExtId ShmList VarMem.UnLock " & ExtendedId
    FreeEntry(CurrentItem)

    Return value

End

Public Sub Pop() As Variant

    If ListHead.value > 0 Then
        Return Remove(-1)
    Else
        Error.Raise("Dequeue : empty queue")
    Endif

End

Public Sub Push(value As Variant, Optional ExtendedID As Long = 0, TagInfo As String = "Push")

    add(value, ExtendedID, TagInfo)

End

'' Remove element by index value, or the last element by default
'' Returns the value of the element
Public Sub remove(Optional Index As Long = -1) As Variant

    Dim currentItem As DList
    Dim Count As Long = 0
    Dim Value As Variant

    If ListHead.next = Null Or Index >= CLong(ListHead.value) Then
        ' Return Null
        Error.Raise("Out Of Bounds - remove Index : " & Index)
    Endif

    If ListHead.bDebug Then
        Print Application.id, "Remove ShmList VarMem.Lock " & Index
    Endif

    varmem.Lock()

    If Index = 0 Then
        CurrentItem = EntryPtr(ListHead.next)
    Else If Index < 0 Then
        CurrentItem = EntryPtr(ListHead.prev)
    Else
        CurrentItem = EntryPtr(ListHead.next)

        While Count < Index
            CurrentItem = EntryPtr(CurrentItem.next)
            If CurrentItem = Null Then Break
            Inc count
        Wend

    Endif

    If CurrentItem = Null Then
        varmem.Unlock()
        Error.Raise("Out of Bounds - Remove by index : " & index)
    Endif

    value = _remove(CurrentItem)

    ' Dim addr As Pointer = CurrentItem.address
    ' Value = VarMem[CurrentItem.value]                            ' get the value of the item being removed
    '
    ' If addr = ListHead.next Then
    '     ListHead.next = CurrentItem.Next
    '     If CurrentItem.next = 0 Then
    '         ListHead.prev = 0
    '     Endif
    ' Else If addr = ListHead.prev Then
    '     ListHead.prev = CurrentItem.prev
    '     PtrPrev = EntryPtr(CurrentItem.prev)
    '     ptrPrev.next = 0
    ' Else
    '     ptrnext = EntryPtr(currentItem.next)
    '     ptrprev = EntryPtr(CurrentItem.prev)
    '     ptrnext.prev = ptrprev.address
    '     ptrprev.next = ptrnext.address
    ' Endif
    '
    ' Dec ListHead.value
    '

    varmem.Unlock()

    If ListHead.bDebug Then Print Application.id, "Remove ShmList VarMem.UnLock " & Index & " Value=" & value

    FreeEntry(CurrentItem)

    Return Value

End

'' Remove an element by its virtual address as the key
'' returns the value of the element
Public Sub RemoveByVirt(VirtAddress As Pointer) As Variant

    Dim currentItem As DList

    If ListHead.next = 0 Then
        Error.Raise("Empty List - Virtual Address Not Found : " & VirtAddress)
    Endif

    Dim Value As Variant

    If ListHead.bDebug Then Print Application.id, "RemoveByVirt ShmList VarMem.Lock " & VirtAddress
    varmem.Lock()

    CurrentItem = EntryPtr(ListHead.next)

    While CurrentItem And CurrentItem.address <> VirtAddress
        CurrentItem = EntryPtr(CurrentItem.next)
    Wend

    If Not CurrentItem Then
        varmem.Unlock()
        If ListHead.bDebug Then Print Application.id, "RemoveByVirt ShmList VarMem.UnLock " & VirtAddress
        Error.Raise("Not Found - Virtual Address : " & VirtAddress)
    Endif

    Value = _remove(CurrentItem)

    varmem.Unlock()
    If ListHead.bDebug Then Print Application.id, "RemoveByVirt ShmList VarMem.UnLock " & VirtAddress
    FreeEntry(CurrentItem)

    Return value

End

'' Duplicate the head of the list but include the same entries in both lists
Public Sub Dup() As Variant

    Dim newlist As Variant = Object.Class(Me).New([VarMem, 0, Me.ListHead.global, "Dup:" & Me.tag])

    newlist.listhead.Next = Me.ListHead.Next
    newlist.ListHead.prev = Me.ListHead.Prev
    newlist.ListHead.value = Me.ListHead.Value
    Return newlist

End

'' Create a deep copy of the list
Public Sub {Copy}() As Variant

    Dim newlist As Variant
    Dim NewExtendedID As Long
    Dim NewTag As String

    newlist = Object.Class(Me).New([VarMem, 0, Me.ListHead.Global, "Copy:" & Me.tag])

    For Each v As Variant In Me                         'Move the values To the New List
        NewExtendedId = Me.Key_ExtendedId
        NewTag = Me.Key_Tag
        newlist.add(v, NewExtendedID, NewTag)
    Next

    Return newlist

End

Private Function key_read() As Long

    If ListHead = Null Then Return 0
    Return ListHead.Enum_counter

End

Private Function Key_Tag_read() As String

    If ListHead = Null Or If ListHead.Enum_Listitem = Null Then Return ""
    Return ListHead.Enum_Listitem.Tag.ToString()

End

Private Function Key_dlist_read() As Dlist

    If ListHead = Null Then Return Null
    Return ListHead.Enum_Listitem

End

Private Function Key_ExtendedId_read() As Long

    If ListHead = Null Or If ListHead.Enum_Listitem = Null Then Return 0
    Return ListHead.Enum_listitem.Priority

End

Public Sub _next() As Variant

    Dim ListItem As DList

    If IsNull(Enum.Index) Then

        If listhead <> Null And If ListHead.Value > 0 Then
            ListItem = EntryPtr(ListHead.next)
            Enum.Index = listhead
            Enum.Index.enum_listitem = listitem
            Enum.Index.enum_counter = 0
        Else
            Enum.Stop
            Return
        Endif
    Else
        listItem = Enum.index.Enum_listitem
        If ListItem.next = Null Then
            Enum.Index.enum_listitem = Null
            Enum.Index.enum_counter = 0
            Enum.Stop
            Return
        Else
            ListItem = EntryPtr(ListItem.next)
            Enum.Index.enum_listitem = listItem
            Inc Enum.Index.enum_Counter
        Endif
    Endif

    Return VarMem[ListItem.value]

End

'' Finds the element with the extended id
'' Returns the index if it is found
'' Returns -1 if not found
Public Sub FindExtId(Value As Long) As Long

    Dim Count As Long = 0

    'Print " FindExtId : ";; Object.Class(Me).name;; "Entries=";; Me.count
    For Each dd As Variant In Me
        If Me.Key_dlist.Priority = value Then
            'Print "FindExtId : Found Extid at ";; Me.count
            Return count
        Endif
        Inc count
    Next
    'Print "FindExtId : not found checked ";; Me.count + 1;; "entries"
    Return -1

End

'' Finds the element with the Virtual Address
'' Returns the index if it is found
'' Returns -1 if not found
Public Sub FindVirtAddress(VirtAddress As Pointer) As Long

    Dim Count As Long = 0

    For Each dd As Variant In Me
        If Me.key_dlist.Address = VirtAddress Then
            Return count
        Endif
        Inc count
    Next
    Return -1

End

'' Check if a specified value exists in the list
'' returns the index if it is found -1 if it is not
Public Sub Find(value As Variant) As Long

    Dim count As Long = 0

    For Each dd As Variant In Me
        If VarMem[Me.Key_dlist.Value] = value Then
            Return count
        Endif
        Inc count
    Next

    Return -1

End

Private Function max_Read() As Long

    Return ListHead.Value - 1

End

Private Function count_Read() As Long

    If ListHead = Null Then Return 0
    Return ListHead.Value

End

Private Function value_Read() As Long

    Return VirtualAddress

End

Private Function Type_Read() As Integer

    Return SetHeadType

End

Private Function Address_Read() As Pointer

    Return VirtualAddress

End

Private Function Debug_Read() As Boolean

    If ListHead = Null Then Return False
    Return ListHead.bDebug

End

Private Sub Debug_Write(Value As Boolean)

    Print "Set debug to ";; value
    If ListHead = Null Then Return
    ListHead.bDebug = Value

End

'' Returns a list Of all the objects Of the same type As This Class
'' from the shared memory
Private Function AllLists_Read() As Variant[]

    Dim ListTable As New Variant[]

    For Each mBlock As Variant In VarMem
        If mBlock.type = SetHeadType Then
            ListTable.Add(mBlock)
        Endif
    Next

    Return ListTable

End

'' returns an array of elements for all list type classes
'' Entries in this list point to the underlaying shared values
'' if you change anything in this list it will affect every other
'' refrence to this list
Private Function AllEntries_read() As Variant[]

    Dim nextitem As Dlist
    Dim items As New Variant[]
    Dim newObject As Object

    nextitem = EntryPtr(listhead.Next)
    While nextitem <> Null
        newObject = Object.New(VarMem.GetTextType(nextitem.Type), [varmem, nextitem.address])
        items.Add(newObject)
        nextitem = EntryPtr(NextItem.Next)
    Wend
    Return items

End

Private Function Tag_Read() As String

    If ListHead = Null Then Return ""
    Return Trim(ListHead.Tag.ToString())

End

Private Sub Tag_Write(Value As String)

    If ListHead = Null Then Return
    Dim rValue As String = Left(value & Space(ListHead.Tag.length), ListHead.Tag.length)

    For i As Integer = 0 To ListHead.Tag.length - 1
        ListHead.Tag[i] = Asc(rValue[i])
    Next

End

Public Sub textTree() As String

    Dim Indent As String = "    "
    Dim entry As Variant

    For Each entry In Me
        Print indent;; Me.key
    Next

End

'cShmList As Integer = 20                  '' The Constant identifying this class name must not be a valid datatype integer
'cShmListEntry As Integer = 21        '' The entry in a ShmList object type
Private Function ClassList_Read() As String

    Return varmem.GetTextType(cShmList)

End

Private Function ClassEntry_Read() As String

    Return varmem.GetTextType(cShmListEntry)

End

Private Function ClassMe_Read() As String

    Return varmem.GetTextType(ListHead.Type)

End
