' Gambas class file

' Author Westwood JustLostintime
'Released Under:
'  GNU GENERAL Public LICENSE
'  Version 3, 29 June 2007
'  See project license file.

Export
'Fast Unsafe

''' Defines the Shm datatype - list
''' Lists are inherited by every other list based object

Public Struct AllocHeader              '' Standard header
    Length As Long                              '' Length including header
    Address As Pointer                      '' The virtual address of this block, speed pointer conversion
    Type As Integer                             '' Type of memory
    {Next} As Pointer                          '' null if no more in list
End Struct

Public Struct dPointer
    Length As Long                              '' Length including header
    Address As Pointer                      '' The virtual address of this block, speed pointer conversion
    Type As Integer                             '' Type of memory
    Value As Pointer                            '' The actual value for usage
End Struct

Public Struct dList                             '' A defined entry in list of objects
    Length As Long                              '' Length including header
    Address As Pointer                      '' The virtual address of this block, speed pointer conversion
    Type As Integer                             '' Type of memory
    {Next} As Pointer                          '' Next in list or head of pool
    Prev As Pointer                              '' previous in list or end of pool
    sema As Pointer                             '' The locking semephor for each list
    Global As Integer                           '' Defines if this is a global memory object or not
    bDebug As Boolean                      '' turns on or off the debug control
    Tag[64] As Byte                              '' a user text tag for this list, can be used to identify nameless queues
    RefCount As Long                          '' Number of refrences to this element
    Priority As Long                              '' in a queue this is the priority of this element
    UsePriority As Boolean                '' Enable the use of priority ordering in the list
    enum_counter As Long               '' Used when enumerating a list structure
    enum_listitem As Dlist                 '' pointer to dlist
    Value As Pointer                            '' Value of entry or count if pool
End Struct

Static Public cShmList As Integer = 20                  '' The Constant identifying this class name must not be a valid datatype integer
Static Public cShmListEntry As Integer = 21        '' The entry in a ShmList object type

' Extern DListPtr(dest As Pointer, src As Pointer, Len As Integer) As DList In "libc:6" Exec "memcpy"
' Extern memcpy(dest As Dlist, src As Dlist, Len As Integer) As Integer In "libc:6"

Extern sem_init(mutex As Pointer, shared As Integer, Value As Integer) As Integer In "libpthread:0"
'Extern sem_wait(mutex As Pointer) As Integer In "libpthread:0"
Extern sem_post(mutex As Pointer) As Integer In "libpthread:0"
Extern sem_getvalue(mutex As Pointer, Ivalue As Pointer) As Integer In "libpthread:0"
Extern sem_trywait(mutex As Pointer) As Integer In "libpthread:0"
Extern sem_destroy(mutex As Pointer) As Integer In "libpthread:0"
' Extern sched_yield() As Integer In "libpthread:0"

Private VirtualAddress As Pointer = 0              '' Pointer to the head of the list
Public ListHead As DList                                         '' Pointer to the actual list
Public VarMem As ShmVarStorage                    '' The storage pool to used or referenced
Public SemAddress As Pointer                             '' real pointer to the locking sem used by this list

Property Read Key As Long                                   '' During iterations this will be the item count
Property Read Key_dlist As Dlist                          '' During iteration this contains the current dlist entry
Property Read Key_ExtendedId As Long           '' ExtendedId of the entry being proessed by Next
Property Read Key_Tag As String                       '' The content of the entry tag field

Property Read max As Long                                '' max count for iteration
Property Read count As Long                              '' Count of elements in this list
Property Read value As Long                              '' Returns the virtual address of this list
Property Read Type As Integer                          '' The type of this object
Property Read Address As Pointer                    '' The address of the object
Property Debug As Boolean                                '' Debugging helper
Property Read AllLists As Variant[]                   '' Returns a table of all active List{types} in memory
Property Read AllEntries As Variant[]              '' returns a list of all entries in the list
Property Tag As String                                         '' memo tag for debug and identity purposed
Property Read ClassList As String                     '' The name of the class for this list/entry
Property Read ClassEntry As String                  '' The text name of the list/queue entries
Property Read ClassMe As String                      '' the text class of the current item
Property Read Next As Variant                           '' The actual list structure entry, not the value
Property Read Prev As Variant                            '' The actual list structure entry, Not Value
Property Read Firsts As Variant                            '' first entry in the list
Property Read Last As Variant                               '' Last entry in the list
Property Read RefCount As Variant                      '' Get number of refrences

Public SetHeadType As Integer = cShmList             '' The list header Class
Public SetEntryType As Integer = cShmListEntry    '' The List Entry Class

Static Public Sub _init()

    ShmVarStorage.DefineClass("ShmList", cShmlist)
    ShmVarStorage.DefineClass("ShmListEntry", cShmlistEntry)

End

'' Returns a new allocated list if address is 0, else returns the exsisting list at the specified address
'' VarStorage is the pointer to the address to allocate the list from
'' VirtAddress is the address of an exsiting list, which is returned as a listObject type
'' GlobalValue is used to allow this list to be private or a global value
'' Returns the list as a list
'' Increments the refrence counter for this list

Public Sub _new(VarStorage As Variant, Optional VirtAddress As Pointer = 0, GlobalValue As Boolean = False, Tag As String = "")

    Dim Result As Integer = 0

    If Object.Class(VarStorage).name == "ShmMem" Then
        VarMem = VarStorage.MyVarMem
    Else
        VarMem = VarStorage
    Endif

    Dim RealPtr As Pointer
    If VirtAddress = 0 Then
        ListHead = NewEntry()
        VirtualAddress = ListHead.Address
        ListHead.type = SetHeadType
        ListHead.Global = GlobalValue
        ListHead.sema = VarMem.Alloc(64)
        ListHead.UsePriority = False
        ListHead.Value = 0
        ListHead.tag = Byte[].FromString(tag)
        SemAddress = varmem.RealDataAddress(ListHead.sema)
        result = sem_init(SemAddress, 1, 0)
    Else
        VirtualAddress = VirtAddress
        RealPtr = VarMem.RealAddress(VirtAddress)
        ListHead = RealPtr
        SemAddress = varmem.RealDataAddress(ListHead.sema)
        Me.lock()
        Inc ListHead.RefCount
    Endif
    Me.unlock()

End

Public Sub _free()

    'Print Application.id, "_free Begin for ";; ShmVarStorage.GetTextType(listhead.type);; "Address =";; listhead.Address
    If Listhead <> Null Then
        '   Print Application.id, "_free Doing for ";; ShmVarStorage.GetTextType(listhead.type);; "Address =";; listhead.Address;; "RefCount =";; listhead.refcount
        Me.lock()

        If ListHead.Refcount > IIf(ListHead.global, 1, 0) Then
            Dec ListHead.RefCount
        Endif

        If Not ListHead.Global Then
            If ListHead.RefCount = 0 Then
                Keys = Null
                '          Print Application.id, "_free finish  for ";; ShmVarStorage.GetTextType(listhead.type);; "Address =";; listhead.Address
                Me.Free()
            Else
                Me.unlock()
                '         Print Application.id, "_free Keeps for ";; ShmVarStorage.GetTextType(listhead.type);; "Address =";; listhead.Address;; "Refcount =";; listhead.refcount
            Endif
        Else
            Me.unlock()
            '    Print Application.id, "_free Global for ";; ShmVarStorage.GetTextType(listhead.type);; "Address =";; listhead.Address;; "Refcount =";; listhead.refcount
        Endif

        'Else
        'Print Application.id, "_free  Failed for shmlist dlist is null error"
    Endif

    varmem = Null

End

'' Required for each user defined class, returns the pointer to the under laying data structure
Static Public Sub UserPtr(vvarmem As ShmVarStorage, VirtAddr As Pointer) As Dlist

    If VirtAddr <= 0 Then Return Null
    Dim RealPtr As Pointer = vVarMem.RealAddress(VirtAddr)
    Return RealPtr

End

'' Convert the Virtual address to an actual list object
Static Public Sub AsObject(vvarmem As ShmVarStorage, VirtAddr As Pointer) As ShmList

    Return Object.New(vVarMem.GetTextType(cShmList), [vvarmem, VirtAddr])

End

Public Sub EntryPtr(VirtAddress As Pointer) As DList

    If VirtAddress <= 0 Then Return Null
    Dim RealPtr As Pointer = VarMem.RealAddress(VirtAddress)
    Return RealPtr

End

Public Sub NewEntry(Optional Value As Variant = Null) As DList

    Dim NewVar As Pointer
    Dim Entry As Dlist
    Dim chkval As Variant
    Dim VirtAddress As Pointer
    Dim RealAddress As Pointer
    Dim iType As Integer

    If listhead <> Null And If ListHead.bDebug Then
        Print Application.id, "Create New Entry  ShmList Value =  ";; Str(Value)
    Endif

    VarMem.Lock()
    VirtAddress = VarMem.Alloc(SizeOf(dList) - SizeOf(AllocHeader))
    RealAddress = VarMem.RealAddress(VirtAddress)
    varmem.Unlock()

    entry = RealAddress

    Entry.type = SetEntryType
    Entry.value = 0
    Entry.next = 0
    Entry.prev = 0
    Entry.RefCount = 1

    If value Then
        NewVar = VarMem.set(Value)
        Entry.Value = NewVar
        iType = TypeOf(value)
    Else
        NewVar = Entry.value
        iType = 0
    Endif

    If NewVar > 0 Then
        chkval = VarMem.Getpointer(itype, newvar)
        If chkval.address <> newvar Then                                 ''' here until debugged
            Stop
        Endif
    Endif

    If listhead <> Null And If ListHead.bDebug Then Print Application.id, "Created New Entry  ShmList Element ID =  ";; Str(entry)
    Return Entry

End

''  Lock the list/queue  while processing the request
'' This is not automatic, the user must do this if required
Public Sub {lock}() As Boolean

    Dim result As Integer = -1
    Dim retrycounter As Long = 10

    While result <> 0
        result = sem_trywait(SemAddress)
        If result <> 0 Then
            Wait 0.0001
            Dec RetryCounter
            If retryCounter < 4 Then
                If ListHead.bDebug Then Print Application.id, "ShmList Locking Race condition attempting fix ";; retryCounter
                Me.unlock()
            Endif
        Else
            Return True
        Endif
    Wend
    If ListHead.bDebug Then Print Application.id, "ShmList Locking Race condition attempt to fix failed";; retryCounter
    Return False

End

''  Release the lock on the list/queue
'' Returns false if the lock was not 0, locked
'' be careful as this can be posted anywhere

Public Sub {unlock}() As Boolean

    Dim value As Integer = 0
    Dim iptr As Pointer = VarPtr(value)

    If sem_getvalue(SemAddress, iptr) = 0 Then
        If value = 0 Then
            sem_post(SemAddress)
            Return True
        Endif
    Endif
    Return False

End

Public Sub add(Value As Variant, Optional ExtendedId As Long = 0, TagInfo As String = "")

    Dim NewElement As DList
    Dim LastEntry As Dlist
    Dim RealAddress As Pointer

    If ListHead.bDebug Then Print Application.id, "Add ShmList Value = ";; Str(Value)
    Me.lock()

    NewElement = NewEntry(Value)
    NewElement.Priority = ExtendedId

    If TagInfo <> "" Then
        If TagInfo.len < NewElement.Tag.Length Then TagInfo = Left(TagInfo & Space(NewElement.Tag.Length), NewElement.Tag.Length)
        For i As Integer = 0 To NewElement.tag.length - 1
            NewElement.Tag[i] = Asc(Taginfo[i])
        Next
    Endif

    If ListHead.Next = 0 Then
        ListHead.Next = NewElement.Address
        ListHead.prev = NewElement.Address
    Else
        RealAddress = VarMem.RealAddress(ListHead.prev)
        LastEntry = RealAddress

        ListHead.Prev = NewElement.Address
        NewElement.prev = LastEntry.address
        LastEntry.Next = NewElement.Address
        NewElement.next = Null
    Endif

    Inc ListHead.Value                ' this holds the count of elements in this list

    Me.unlock()

    If ListHead.bDebug Then Print Application.id, "Add ShmList Added Value = ";; Str(value)

End

Public Sub _Assign(VEntry As DPointer)

    Inc ListHead.RefCount                                   '  represents the number of refrences to this entry
    vEntry.Value = ListHead.Address              '  Assign this to the variable

End

Public Sub {Free}()                             '' Free the entire list

    Dim pList As DList[] = AsDListList()

    sem_destroy(VarMem.RealDataAddress(ListHead.sema))

    VarMem.Free(ListHead.sema)
    varmem.Free(VirtualAddress)

    For Each pEntry As DList In pList
        FreeEntry(pEntry)
    Next

    listhead = Null

End

Public Sub Clear()

    Dim pList As DList[] = AsDListList()

    For Each pEntry As DList In pList
        FreeEntry(pEntry)
    Next

    ListHead.value = 0

End

Public Sub AsDlistList() As DList[]

    Dim pList As New DList[]
    Dim Source As Dlist = EntryPtr(ListHead.next)

    While Source
        pList.Add(Source)
        Source = EntryPtr(Source.next)
    Wend

    Return plist

End

Private Sub FreeEntry(Entry As DList)

    If ListHead.bDebug Then Print Application.id, "Free Entry  in ShmList :";; entry.address
    VarMem.Free(Entry.value)                        '' entry will always point to something
    VarMem.Free(entry.address)                   '' Dispose of this item as well

End

Public Sub _get(Index As Integer) As Variant

    Dim Result As Variant
    Dim dPtr As Dlist

    If ListHead.bDebug Then Print Application.id, "_get ShmList index =  " & Index
    Me.lock()

    dPtr = SeekRec(Index)

    If Dptr = Null Then
        Me.unlock()
        If ListHead.bDebug Then Print Application.id, "_get ShmList Record Not Found  returned NULL "
        Return Null
    Endif

    If ListHead.bDebug Then Print Application.id, "_get ShmList VarMem.Lock  index = " & Index & " Dptr = " & Str(dptr)
    VarMem.Lock()
    Result = VarMem[dPtr.value]
    VarMem.Unlock()
    If ListHead.bDebug Then Print Application.id, "_Get ShmList VarMem.UnLock " & Index

    Me.unlock()
    Return result

Finally
    Me.unlock()

Catch
    Error.Propagate()

End

Public Sub _put(Value As Variant, Index As Integer)

    Dim dPtr As Dlist

    If ListHead.bDebug Then Print Application.id, "_put ShmList index = " & Index & " Value = " & Str(value)
    Me.lock()

    dPtr = SeekRec(Index)

    If Dptr = Null Then
        If ListHead.bDebug Then Print Application.id, "_put ShmList Index not found :" & Index
        Error.Raise("Out Of Bounds ")
    Endif

    VarMem.lock()
    VarMem[dPtr.value] = Value
    VarMem.Unlock()

    Me.unlock()
    If ListHead.bDebug Then Print Application.id, "_put ShmList Success at " & Index & "Value = " & Str(value)

Catch
    Me.unlock()
    Error.Propagate()

End

Public Sub insert(Index As Long, value As Variant, Optional ExtendedId As Integer = 0, TagInfo As String = "")

    Dim Current As Dlist
    Dim ptrPrev As DList
    Dim NewItem As Dlist = NewEntry(Value)

    If ListHead.bDebug Then Print Application.id, "Insert ShmList  at index =  " & Str(Index)

    Me.lock()

    If TagInfo <> "" Then
        If TagInfo.len < NewItem.Tag.Length Then TagInfo = Left(TagInfo & Space(NewItem.Tag.Length), NewItem.Tag.Length)
        For i As Integer = 0 To NewItem.tag.length - 1
            NewItem.Tag[i] = Asc(Taginfo[i])
        Next
    Endif

    NewItem.Priority = ExtendedId

    If Index = 0 Then
        If ListHead.Next = 0 Then
            ListHead.next = NewItem.Address
            ListHead.prev = NewItem.Address
        Else
            Current = EntryPtr(ListHead.next)
            Current.prev = NewItem.address
            NewItem.Next = Current.Address
            ListHead.Next = NewItem.address
        Endif
    Else If Index = -1 Then
        If ListHead.prev = 0 Then
            ListHead.next = NewItem.Address
            ListHead.prev = NewItem.Address
        Else
            Current = EntryPtr(ListHead.Prev)
            Current.next = NewItem.Address
            NewItem.Prev = Current.Address
            ListHead.Prev = NewItem.address
        Endif
    Else
        Current = SeekRec(Index)

        If Not Current Then
            Me.Unlock()
            If ListHead.bDebug Then Print Application.id, "Insert ShmList out of bounds index = " & Str(Index)
            Error.Raise("Out Of Bounds")
        Endif

        If Current.Address = ListHead.next Then
            Current.Prev = NewItem.Address
            ListHead.next = NewItem.Address
            NewItem.Next = Current.address
        Else
            ptrprev = EntryPtr(Current.prev)
            Current.prev = NewItem.address
            NewItem.next = Current.address
            NewItem.prev = ptrPrev.Address
            ptrPrev.Next = NewItem.address
        Endif

    Endif

    Inc ListHead.Value

    Me.Unlock()
    If ListHead.bDebug Then Print Application.id, "Insert ShmList completed for index = " & Str(Index)

Catch
    Me.unlock()
    Error.Propagate()

End

'' look for the index element and return the Element(dlist Struct)
'' containing the element entry
Private Sub SeekRec(Index As Integer) As DList

    Dim Count As Integer
    Dim Current As DList

    If Index < 0 Or If Index >= ListHead.Value Then
        Return Null
    Endif

    Current = EntryPtr(ListHead.next)

    While Count < Index
        Current = EntryPtr(Current.next)
        Inc Count
    Wend

    If current = Null Then
        Stop
    Endif

    Return Current

End

Private Sub _remove(CurrentItem As Dlist) As Variant

    Dim addr As Pointer = CurrentItem.address
    Dim value As Variant
    Dim ptrprev As Dlist
    Dim ptrNext As Dlist

    Value = VarMem[CurrentItem.value]                            ' get the value of the item being removed

    If addr = ListHead.next Then                                          ' if this is the head of the queue
        ListHead.next = CurrentItem.Next                            ' ListHead Next should point to Whatever current item points to
        If ListHead.next = Null Then                                        ' if this was only one on list
            ListHead.prev = Null                                                  ' Previous also becomes null
            ListHead.value = 0                                                      ' Empty the queue
        Else
            ptrnext = EntryPtr(ListHead.next)                        ' check if just one item on the queue
            If ptrnext.Next = Null Then                                     ' If it is then
                ListHead.Prev = ListHead.Next                          ' it also becoms the previous item
            Endif
        Endif
    Else If addr = ListHead.prev Then                                ' if the address matches the end of the queue
        ListHead.prev = CurrentItem.prev                           ' Set the Previous to the current item previous
        PtrPrev = EntryPtr(CurrentItem.prev)                    ' get the physical address of the previous entry
        ptrPrev.next = Null                                                       ' Since we are at the end of the list just set it to null
    Else
        ptrnext = EntryPtr(currentItem.next)                     ' Well we must be in the list then Get Pysical address of next item
        ptrprev = EntryPtr(CurrentItem.prev)                    ' get the pysical address of the previous item
        ptrnext.prev = ptrprev.address                              ' Point the next items previous to current item previous
        ptrprev.next = ptrnext.address                              ' Point the previous items next to the current items next
    Endif

    If listhead.value > 0 Then Dec ListHead.value

    currentItem.Next = Null
    CurrentItem.prev = Null

    Return Value

End

'' Remove an element from the list based upon the extended id
'' Returns the value of the entry
Public Sub RemoveExtId(ExtendedId As Long) As Variant

    Dim currentItem As DList
    Dim Value As Variant

    If ListHead.bDebug Then Print Application.id, "RemoveExtId ShmList For " & ExtendedId
    Me.lock()

    If ListHead.next = 0 Then
        Me.unlock()
        If ListHead.bDebug Then Print Application.id, "RemoveExtId ShmList For " & ExtendedId & " Failed empty list"
        Error.Raise("Empty List - Extended ID : " & ExtendedID)
    Endif

    CurrentItem = EntryPtr(ListHead.next)

    ' search for the matching value
    While CurrentItem <> Null
        If CurrentItem.Priority = ExtendedId Then Break
        CurrentItem = EntryPtr(CurrentItem.next)
    Wend

    If CurrentItem = Null Then
        Me.Unlock()
        If ListHead.bDebug Then Print Application.id, "RemoveByExtId ShmList VarMem.UnLock " & ExtendedId
        Error.Raise("Not Found -  Extended ID : " & Value)
    Else
        If ListHead.bDebug Then Print Application.id, "RemoveExtId ShmList For " & ExtendedId & " Found"
    Endif

    value = _remove(CurrentItem)

    Me.unlock()

    If ListHead.bDebug Then Print Application.id, "RemoveExtId ShmList VarMem.UnLock " & ExtendedId

    FreeEntry(CurrentItem)

    Return value

Finally
    Me.unlock()

Catch
    Dim myerror As String = Error.text & Error.where
    Error.Raise(myerror)

End

'' Pop the next entry, but return all the fields from the entry
Public Sub PopInfo() As Variant[]

    Dim result As New Variant[]
    Dim all As DList[] = AsDlistList()

    result.Add(all.Last.Tag)
    result.Add(all.Last.Priority)
    Result.Add(Pop())
    Return result

End

Public Sub Pop() As Variant

    If ListHead.value > 0 Then
        Return Remove(-1)
    Else
        Error.Raise("Pop : empty queue")
    Endif

End

Public Sub Push(value As Variant, Optional ExtendedID As Long = 0, TagInfo As String = "Push")

    add(value, ExtendedID, TagInfo)

End

'' Remove element by index value, or the last element by default
'' Returns the value of the element
Public Sub remove(Optional Index As Long = -1) As Variant

    Dim currentItem As DList
    Dim Count As Long = 0
    Dim Value As Variant

    Me.lock()
    If ListHead.bDebug Then
        Print Application.id, "Remove ShmList Item " & Index
    Endif

    If ListHead.next = Null Or Index >= CLong(ListHead.value) Then
        Me.unlock()
        If ListHead.bDebug Then Print Application.id, "Remove ShmList Item failed out of bounds " & Index
        Error.Raise("Out Of Bounds - remove Index : " & Index)
    Endif

    If Index = 0 Then
        CurrentItem = EntryPtr(ListHead.next)
    Else If Index < 0 Then
        CurrentItem = EntryPtr(ListHead.prev)
    Else
        CurrentItem = EntryPtr(ListHead.next)

        While Count < Index
            CurrentItem = EntryPtr(CurrentItem.next)
            If CurrentItem = Null Then Break
            Inc count
        Wend

    Endif

    If CurrentItem = Null Then
        Me.unlock()
        Error.Raise("Out of Bounds - Remove by index : " & index)
    Endif

    value = _remove(CurrentItem)

    Me.unlock()

    If ListHead.bDebug Then Print Application.id, "Remove ShmList VarMem.UnLock " & Index & " Value=" & value

    FreeEntry(CurrentItem)

    Return Value

Finally
    Me.unlock()

Catch
    Error.Propagate()

End
' Remove an element by its value as the key
'' returns the value of the element

Public Sub RemoveByValue(vValue As Variant) As Variant

    Dim currentItem As DList
    Dim Value As Variant

    If ListHead.bDebug Then Print Application.id, "RemoveByValue ShmList  " & Str(vValue)
    Me.lock()

    If ListHead.next = 0 Then
        If ListHead.bDebug Then Print Application.id, "RemoveByValue ShmList  not found " & Str(vValue)
        Error.Raise("Empty List - Value Not Found : " & Str(vValue))
    Endif

    CurrentItem = EntryPtr(ListHead.next)

    While CurrentItem <> Null
        Value = VarMem[CurrentItem.value]                            ' get the value of the item being removed
        If Value = vValue Then Break
        CurrentItem = EntryPtr(CurrentItem.next)
    Wend

    If Not CurrentItem Then
        Print Application.id, "RemoveByValue ShmList Not found  " & Str(vValue)
        Error.Raise("Not Found - Value : " & Str(vValue))
    Endif

    Value = _remove(CurrentItem)

    Me.unlock()

    If ListHead.bDebug Then Print Application.id, "RemoveByValue ShmList  Found  " & Str(vValue)

    FreeEntry(CurrentItem)

    Return value

Finally
    Me.unlock()

Catch
    Error.Propagate()

End

'' Remove an element by its virtual address as the key
'' returns the value of the element
Public Sub RemoveByVirt(VirtAddress As Pointer) As Variant

    Dim currentItem As DList

    If ListHead.bDebug Then Print Application.id, "RemoveByVirt ShmList  " & VirtAddress
    Me.lock()

    If ListHead.next = 0 Then
        If ListHead.bDebug Then Print Application.id, "RemoveByVirt ShmList  not found " & VirtAddress
        Error.Raise("Empty List - Virtual Address Not Found : " & VirtAddress)
    Endif

    Dim Value As Variant

    CurrentItem = EntryPtr(ListHead.next)

    While CurrentItem <> Null
        If CurrentItem.address = VirtAddress Then Break
        CurrentItem = EntryPtr(CurrentItem.next)
    Wend

    If Not CurrentItem Then
        Print Application.id, "RemoveByVirt ShmList Not found  " & VirtAddress
        Error.Raise("Not Found - Virtual Address : " & VirtAddress)
    Endif

    Value = _remove(CurrentItem)
    Me.unlock()

    If ListHead.bDebug Then Print Application.id, "RemoveByVirt ShmList  Found  " & VirtAddress

    FreeEntry(CurrentItem)

    Return value

Finally
    Me.unlock()

Catch
    Error.Propagate()

End

'' Duplicate the head of the list but include the same entries in both lists
Public Sub Dup() As Variant

    Dim newlist As Variant = Object.Class(Me).New([VarMem, 0, Me.ListHead.global, "Dup:" & Me.tag])

    Me.lock()
    newlist.listhead.Next = Me.ListHead.Next
    newlist.ListHead.prev = Me.ListHead.Prev
    newlist.ListHead.value = Me.ListHead.Value
    ' now we need to increment each elements refcount to account for this list
    Dim currentItem As Dlist = EntryPtr(newlist.listhead.next)

    While currentItem <> Null
        Inc currentItem.RefCount
        currentItem = EntryPtr(CurrentItem.next)
    Wend

    Me.unlock()
    Return newlist

Finally
    Me.unlock()

Catch
    Error.Propagate()

End

'' Create a deep copy of the list
Public Sub {Copy}() As Variant

    Dim newlist As Variant
    Dim NewExtendedID As Long
    Dim NewTag As String

    newlist = Object.Class(Me).New([VarMem, 0, Me.ListHead.Global, "Copy:" & Me.tag])

    Me.lock()
    For Each v As Variant In Me                         'Move the values To the New List
        NewExtendedId = Me.Key_ExtendedId
        NewTag = Me.Key_Tag
        newlist.add(v, NewExtendedID, NewTag)
    Next
    Me.unlock()

    Return newlist

Finally
    Me.unlock()

Catch
    Error.Propagate

End

Private Function key_read() As Long

    If keys = Null Then Return -1
    Return keys.counter

End

Private Function Key_Tag_read() As String

    If keys = Null Then Return ""
    Return keys.Elements[keys.counter].tag

End

Private Function Key_dlist_read() As Dlist

    If keys = Null Then Return Null
    Return keys.Elements[keys.counter].dlist

End

Private Function Key_ExtendedId_read() As Long

    If keys = Null Then Return -1
    Return keys.Elements[keys.counter].Priority

End

Private Keys As NextInfo = Null

Public Sub _next() As Variant

    Dim enumEntry As NextInfo

    If IsNull(Enum.Index) Then

        If listhead <> Null Then
            enumentry = New NextInfo(_allEntries())
            If enumentry.Elements.Count = 0 Then
                keys = Null
                Enum.Stop()
                Return
            Endif
            Enum.Index = enumentry
        Else
            keys = Null
            Enum.Stop()
            Return
        Endif
    Else
        Inc Enum.Index.counter
        If Enum.Index.counter = Enum.Index.elements.count Then
            keys = Null
            Enum.Stop()
            Return
        Endif
    Endif

    keys = Enum.index
    Return keys.elements[keys.Counter].Value

Catch
    Error.Propagate()

End

'' Finds the element with the extended id
'' Returns the index if it is found
'' Returns -1 if not found
Public Sub FindExtId(Value As Long) As Long

    Dim Count As Long = 0
    Dim Result As Long = -1

    If listhead.bDebug Then Print Application.id, "FindExtId : ";; Object.Class(Me).name;; "Entries=";; Me.count

    For Each dd As Variant In Me

        If Me.key_dlist = Null Then
            Break
        Endif

        If Me.Key_dlist.Priority = value Then
            Result = count
            Break
        Endif

        Inc count
    Next

    If listhead.bDebug Then Print Application.id, "FindExtId : checked ";; Me.count + 1;; "entries, index="; result
    Return result

Catch
    Error.Propagate()

End

'' Finds the element with the Virtual Address
'' Returns the index if it is found
'' Returns -1 if not found
Public Sub FindVirtAddress(VirtAddress As Pointer) As Long

    Dim Count As Long = 0
    Dim result As Long = -1

    If listhead.bDebug Then Print " FindVirtAddress : ";; Object.Class(Me).name;; "Entries=";; Me.count

    For Each dd As Variant In Me
        If Me.key_dlist = Null Then Break
        If Me.key_dlist.Address = VirtAddress Then
            result = count
            Break
        Endif
        Inc count
    Next

    If listhead.bDebug Then Print "FindVirtAddress : checked ";; Me.count + 1;; "entries, index="; result
    Return result

Catch
    Error.Propagate()

End

'' Check if a specified value is stored in the list
'' returns the index if it is found -1 if it is not

Public Sub Find(value As Variant, Optional ReturnElement As Boolean = False) As Variant

    Dim count As Long = 0
    Dim Result As Long = -1

    If listhead.bDebug Then Print " Find Value : ";; Object.Class(Me).name;; "Entries=";; Me.count

    For Each dd As Variant In Me
        If Me.key_dlist = Null Then Break
        If VarMem[Me.Key_dlist.Value] = value Then
            result = count
            Break
        Endif
        Inc count
    Next

    If listhead.bDebug Then Print "Find Value : checked ";; Me.count + 1;; "entries, index="; result
    If ReturnElement Then
        Return Object.New(VarMem.GetTextType(Me.key_dlist.Type), [varmem, Me.key_dlist.address])
    Else
        Return result
    Endif

Catch
    Error.Propagate()

End

Private Function max_Read() As Long

    If ListHead = Null Then Return 0
    Return ListHead.Value - 1

End

Private Function count_Read() As Long

    If ListHead = Null Then Return 0
    Return ListHead.Value

End

Private Function value_Read() As Long

    Return VirtualAddress

End

Private Function Type_Read() As Integer

    Return SetHeadType

End

Private Function Address_Read() As Pointer

    Return VirtualAddress

End

Private Function Debug_Read() As Boolean

    If ListHead = Null Then Return False
    Return ListHead.bDebug

End

Private Sub Debug_Write(Value As Boolean)

    Print "Set debug to ";; value
    If ListHead = Null Then Return
    ListHead.bDebug = Value

End

'' Returns a list Of all the objects Of the same type As This Class
'' from the shared memory
Private Function AllLists_Read() As Variant[]

    Return ShmMem.GetListType(varmem, SetHeadType)

End

'' returns an array of elements for all list type classes
'' Entries in this list point to the underlaying shared values
'' if you change anything in this list it will affect every other
'' refrence to this list
Private Function AllEntries_read() As Variant[]

    Return _allEntries()

End

Function _allEntries() As Variant[]

    Dim nextitem As Dlist
    Dim items As New Variant[]
    Dim newObject As Object

    Me.lock()
    If varmem = Null Or If listhead = Null Then Return items
    nextitem = EntryPtr(listhead.Next)
    While nextitem <> Null
        newObject = Object.New(VarMem.GetTextType(nextitem.Type), [varmem, nextitem.address])
        items.Add(newObject)
        nextitem = EntryPtr(NextItem.Next)
    Wend
    Me.unlock()

    Return items

Finally
    Me.unlock()

Catch
    Error.Propagate()

End

Private Function Tag_Read() As String

    If ListHead = Null Then Return ""
    Return Trim(ListHead.Tag.ToString())

End

Private Sub Tag_Write(Value As String)

    If ListHead = Null Then Return
    listhead.tag = Byte[].FromString(value)

End

Public Sub textTree() As String

    Dim result As String = ""
    Dim Indent As String = "    "
    Dim entry As Variant

    Result = "Tree for : " & Me.tag & " Total Entries " & Me.count & "\n"
    For Each entry In Me
        Result &= Subst("&1&2 &3 &4 \t\t&5\n", indent, Me.key, Me.Key_Tag, Me.Key_ExtendedId, ShmVarStorage.GetTextType(Me.key_dlist.Type))
    Next

    Return result

End

'cShmList As Integer = 20                  '' The Constant identifying this class name must not be a valid datatype integer
'cShmListEntry As Integer = 21        '' The entry in a ShmList object type
Private Function ClassList_Read() As String

    Return varmem.GetTextType(cShmList)

End

Private Function ClassEntry_Read() As String

    Return varmem.GetTextType(cShmListEntry)

End

Private Function ClassMe_Read() As String

    Return varmem.GetTextType(ListHead.Type)

End

Private Function Next_Read() As Variant

    If Listhead <> Null And If listhead.Next <> Null Then
        Dim nextitem As Dlist = EntryPtr(listhead.Next)
        Return object.new(VarMem.GetTextType(nextitem.type), [varmem, nextitem.Address])
    Endif
    Return Null

End

Private Function Prev_Read() As Variant

    If Listhead <> Null And If listhead.prev <> Null Then
        Dim previtem As Dlist = EntryPtr(listhead.prev)
        Return object.new(VarMem.GetTextType(previtem.type), [varmem, previtem.Address])
    Endif
    Return Null

End

Private Function Firsts_Read() As Variant

    Dim value As Variant = Null

    If Listhead <> Null And If listhead.next <> Null Then
        Dim CurrentItem As Dlist = EntryPtr(listhead.next)
        Value = VarMem[CurrentItem.value]
    Endif
    Return value

End

Private Function Last_Read() As Variant

    Dim value As Variant = Null

    If Listhead <> Null And If listhead.prev <> Null Then
        Dim CurrentItem As Dlist = EntryPtr(listhead.prev)
        Value = VarMem[CurrentItem.value]
    Endif
    Return value

End

Private Function RefCount_Read() As Variant

    Return ListHead.RefCount

End
