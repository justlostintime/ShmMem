' Gambas class file

''' Shm Array is implemented as linear array of pointers each pointer pointing to the assigned value
'''    Each assigned value used as standard dPointer header to store the data, arrays are variant
'''   any type of data may be stored in them
'''   For each, scanns thru the entire array row by row according to the number of dimensions
'''   it is possible to use SUBMAX(Dim_index) for each subscript of an array
'''   max always returns the linear max for the array
'''   The Max number of Subscripts for an array is 10, this is way too big...
'''   The Array Pysical index (one index per element) memory must fit within a contiguous block or it will fail
'''   Value memory is not created until first use
'''   Array Dimensions are static, fixed at creation, if you need dynamic array then use list

Export

Static Public cShmArray As Integer = 28                             '' The Constant identifying this class name must not be a valid datatype integer
Static Public Const MaxArrayDims As Integer = 10          '' Max array dimensions
Private $IterateAll As Boolean = True                                   '' set default behaviour for iteration
Private $UseLock As Boolean = False                                    '' Set default to not lock array during access

Public Struct AllocHeader              '' Standard header
    Length As Long                              '' Length including header
    Address As Pointer                      '' The virtual address of this block, speed pointer conversion
    Type As Integer                             '' Type of memory
    {Next} As Pointer                          '' null if no more in list
End Struct

'' Data Pointer for complex types
Public Struct dPointer
    Length As Long                              '' Length including header
    Address As Pointer                      '' The virtual address of this block, speed pointer conversion
    Type As Integer                             '' Type of memory
    Value As Pointer                            '' The actual value for usage
End Struct

'' Array Header structure for all types
Public Struct dArray
    Length As Long                                                                  '' Length including header
    Address As Pointer                                                          '' The virtual address of this block, speed pointer conversion
    Type As Integer                                                                 '' Type of array
    {Next} As Pointer                                                              '' never really used except if free block
    dimensions[MaxArrayDims] As Long                          '' The actual dimensions of the array max 64
    DimCount As Integer                                                        '' The number of used dimentions
    Count As Integer                                                                '' The number of elements in the array
    DataAddress As Pointer                                                 '' Pointer to where the memory is located
    Sema As Pointer                                                                '' The locking sema virtual address
    bDebug As Boolean                                                          '' debug flag for this datatype
    Tag[64] As Byte                                                                  '' Tag id of array
End Struct

Extern sem_init(mutex As Pointer, shared As Integer, Value As Integer) As Integer In "libpthread:0"
'Extern sem_wait(mutex As Pointer) As Integer In "libpthread:0"
Extern sem_post(mutex As Pointer) As Integer In "libpthread:0"
Extern sem_getvalue(mutex As Pointer, Ivalue As Pointer) As Integer In "libpthread:0"
Extern sem_trywait(mutex As Pointer) As Integer In "libpthread:0"
Extern sem_destroy(mutex As Pointer) As Integer In "libpthread:0"
' Extern sched_yield() As Integer In "libpthread:0"

Private VirtualAddress As Pointer = 0                  '' Virtual pointer to darray in memory
Private VarMem As ShmVarStorage                    '' The storage pool to used or referenced
Private SemAddress As Pointer                             '' pointer to the semaphor Physical address for the array
Public ArrayDef As DArray                                       '' the actual array header
Private DefaultValue As Variant = 0                     '' Default value returnd when accessing an empty slot
Public ArrayData As DPointer = Null                     '' pointer to the physical memory of the array pointers
Public SemaData As Dpointer = Null                     '' Fortesting Pointer to physical address of the semaphore
Public DataPhysAddr As Pointer = Null                '' for debugging this is the assigned memory

Property Read Count As Long                                '' return the number of elements in the array
Property Read Max As Long                                   '' Return the max element address linear
Property Read Dimensions As Long[]                  '' Return an array of dimensions
Property Read Bounds As Integer[]                     '' same as Dimensions
Property Read Address As Pointer                      '' Returns a pointer to the virtual address of the data memory
Property Read VirtAddress As Pointer               '' returns the darray virtual address
Property Read SubMax As Long[]                        '' Returns an array of Max values for each subscript
Property Default As Variant                                    '' sets or reads the default value returned when a entry is empty
Property Read Value As Variant                            '' returns the same as count, number of elements in array
Property Tag As String                                             '' Returns or set the tag value of the array
Property Read Type As Integer                               '' return the array type, not the data type
Property IterateAll As Boolean                                '' sets if should iterate through every value or only occupied cell values
Property UseLock As Boolean                                  '' sets if the array is locked during every access
Property Read Key As Long[] Use $key                '' the array subscript of the last value read
Property Read Length As Long                                '' Same as the Count for arrays
Property Read First As Variant                                '' get the first element of the array
Property Read Last As Variant                                 '' get the last element of the array
Property Read Dim As Integer                                  '' the number of dimensions
Property Read MemoryPool As ShmVarStorage '' get the pool this array belongs to

'' Initialize the new  class by adding it to the list of datatypes
Static Public Sub _init()

    ShmVarStorage.DefineClass("ShmArray", cShmArray)

End

'' Required for each user defined class, returns the pointer to the under laying data structure
Static Public Sub UserPtr(vvarmem As ShmVarStorage, VirtAddr As Pointer) As DArray

    If VirtAddr <= 0 Then Return Null
    Dim RealPtr As Pointer = vVarMem.RealAddress(VirtAddr)
    Return RealPtr

End

'' Return a list of arrays in memory
Static Public Sub list(VarStorage As Variant) As ShmArray[]

    Dim vvarmem As ShmVarStorage

    If Object.Class(VarStorage).name == "ShmMem" Then
        vVarMem = VarStorage.MyVarMem
    Else
        vVarMem = VarStorage
    Endif

    Dim Result As ShmArray[] = ShmMem.GetListType(vvarmem, cShmArray)

    Return result

End

'' Create a new Array or a new refrence to an exsisting array
'' Array  may be accessed or created, VirtAddressOrTag = 0 then creat new list
''                                                                      VirtAddressOrTag = "tagname" then lookfor and return list with this tag
''                                                                      VirtAddressOrTag > 0 then return list at this virtual address
''                                                                      VarStorage = type of stream  initialize from a file
Public Sub _new(Optional VarStorage As Variant = Null, SubscriptsOrVirtAddressOrTag As Variant = 0, Tag As String = "")

    Dim pType As Integer = TypeOf(VarStorage)

    If varstorage = Null Then
        Return
    Else If ptype = gb.object And If VarStorage Is Stream Then
        Dim MyValue As ShmArray
        MyValue = Read #VarStorage As Object
        _Configure(MyValue.MemoryPool, MyValue.VirtAddress, MyValue.tag)
    Else
        _Configure(VarStorage, SubscriptsOrVirtAddressOrTag, Tag)
    Endif

End
'' Compare value, convert to string if not same type

Public Sub _compare(Value As Variant) As Integer

    Dim i As Integer
    Dim rvalue, lvalue As Variant

    If value Is Array Then
        Error.Raise("ShmArray Unable to compare shmArray to ShmArray[]")
    Endif

    If ArrayDef.Address = value.address Then Return 0
    If ArrayDef.count > value.count Then Return 1
    If ArrayDef.count < value.count Then Return -1

    For i = 0 To ArrayDef.Count - 1

        lvalue = _get(i)
        rvalue = value[i]

        If TypeOf(lvalue) <> TypeOf(rvalue) Then   ' convert to string if not same data type
            lvalue = Str(lvalue)
            rvalue = Str(rvalue)
        Endif

        If lvalue = rvalue Then Continue
        If lvalue > rvalue Then Return 1
        Return -1

    Next
    Return 0

End

Private Sub _Configure(Optional VarStorage As Variant = Null, SubscriptsOrVirtAddressOrTag As Variant = 0, Tag As String = "")

    Dim pType As Integer
    Dim Result As Integer = 0
    Dim total As Integer = 0
    Dim Virtaddress As Pointer = 0
    Dim Dims As New Long[]

    pType = TypeOf(SubscriptsOrVirtAddressOrTag)

    If Object.Class(VarStorage).name == "ShmMem" Then
        VarMem = VarStorage.MyVarMem
    Else
        VarMem = VarStorage
    Endif

    If ptype = gb.pointer Or If pType = gb.long Or If ptype = gb.integer Then
        VirtAddress = SubscriptsOrVirtAddressOrTag
    Else If ptype = gb.string Then
        VirtAddress = locateByTag(SubscriptsOrVirtAddressOrTag)
        If VirtAddress = Null Then
            Error.Raise("ShmArray: Tag name not found :" & SubscriptsOrVirtAddressOrTag)
        Endif
    Else
        Dims = SubscriptsOrVirtAddressOrTag
    Endif

    If Dims.count > MaxArrayDims Then
        Error.Raise("ShmArray : Max Array Dimensions exceeds Maximum :" & MaxArrayDims & "Your Count :" & Dims.count)
    Endif

    If VirtAddress = 0 Then

        If Dims.count = 0 Then
            Error.Raise("ShmArray: Arrays must have at least 1 dimension")
        Endif

        VirtualAddress = VarMem.Alloc(SizeOf(dArray))

        ArrayDef = varmem.RealAddress(VirtualAddress)
        ArrayDef.type = cShmArray
        ArrayDef.sema = VarMem.Alloc(64)
        SemAddress = varmem.RealDataAddress(ArrayDef.sema)
        SemaData = varmem.RealAddress(ArrayDef.Sema)
        result = sem_init(SemAddress, 1, 0)
        ArrayDef.DimCount = Dims.count

        Total = 1
        For i As Integer = 0 To Dims.max
            ArrayDef.dimensions[i] = Dims[i]
            Total *= Dims[i]
        Next

        ArrayDef.Count = total
        Total *= SizeOf(gb.pointer)

        ArrayDef.DataAddress = VarMem.Alloc(Total)                   ' alloc always clears the memory
        ArrayData = VarMem.RealAddress(ArrayDef.DataAddress)
        DataPhysAddr = VarMem.RealDataAddress(ArrayDef.DataAddress)
        ArrayDef.tag = Byte[].FromString(tag)
    Else
        ' VirtualAddress = locateByAddress(VirtAddress) ' caused endleass loop must do it here
        ' If VirtualAddress = Null Then
        '     Error.Raise("ShmArray new: Invalid Virtual address provided")
        ' Endif
        VirtualAddress = VirtAddress
        ArrayDef = VarMem.RealAddress(VirtAddress)
        SemAddress = varmem.RealDataAddress(ArrayDef.sema)
        Me.lock()
    Endif

    Me.unlock()

End

'' shmread is required for shared memory objects
Public Sub _read(Source As Stream)

    Dim ldim As New Long[10]
    Dim Signature As String
    Dim iDimCount As Integer
    Dim VarInfo As Variant

    Signature = Read #Source As String
    varinfo = shmMem.GetMemSegment(Signature)

    If varinfo = Null Then
        Error.Raise("ShmArray: Unable to find correct ShmMem to put value into, Needed:" & Signature)
    Endif

    Dim lCount As Long = Read #Source As Long
    iDimCount = Read #Source As Integer
    For i As Integer = 0 To iDimCount - 1
        ldim[i] = Read #Source As Long
    Next

    DefaultValue = Read #Source As Variant
    Dim sTag As String = Read #Source As String
    Dim vValue As Variant

    _Configure(VarInfo, ldim.Copy(0, idimcount), stag)

    For i As Integer = 0 To lCount - 1
        vvalue = Read #Source As Variant
        _put(vvalue, i)
    Next

End

Public Sub _write(Dest As Stream)

    Dim value As Variant
    Dim i As Integer

    Write #Dest, Varmem.Signature As String
    Write #Dest, ArrayDef.Count As Long
    Write #Dest, ArrayDef.DimCount As Integer
    For i = 0 To ArrayDef.DimCount - 1
        Write #Dest, ArrayDef.dimensions[i] As Long
    Next
    Write #Dest, DefaultValue As Variant
    Write #Dest, ArrayDef.Tag.ToString() As String

    For i As Integer = 0 To ArrayDef.Count - 1
        value = _get(i)
        Write #Dest, value As Variant
    Next

End

'' Redimension an array, all data is lost
Public Sub ReDim(dims As Long[])

    Dim i As Integer

    If Dims.count > MaxArrayDims Then
        Error.Raise("ShmArray : Max Array Dimensions exceeds Maximum :" & MaxArrayDims & "Your Count :" & Dims.count)
    Endif
    If Dims.count = 0 Then
        Error.Raise("ShmArray: Arrays must have at least 1 dimension")
    Endif

    Me.lock()
    Me.clear()                                                                                                                                            ' clear the existing array, frees all the data contained in it
    varmem.Free(ArrayDef.DataAddress)                                                                                       ' free the array if pointers to array values
    ArrayDef.dimcount = dims.Count
    Array.count = 1
    For i = 0 To dims.max
        ArrayDef.dimensions[i] = dims[i]
        Array.count *= Dims[i]
    Next

    ArrayDef.DataAddress = VarMem.Alloc(ArrayDef.Count * SizeOf(gb.pointer))        ' alloc always clears the memory
    ArrayData = VarMem.RealAddress(ArrayDef.DataAddress)
    DataPhysAddr = VarMem.RealDataAddress(ArrayDef.DataAddress)

Finally
    Me.unlock()

End

'' Locate an array by tag name in the shared memory soace
Private Sub locateByTag(tag As String) As Pointer

    Dim result As Pointer = Null

    For Each mBlock As Variant In VarMem
        If mBlock.type = CshmArray
            If mBlock.tag == tag Then
                result = mBlock.VirtAddress
                Break
            Endif
        Endif
    Next

    Return result

End

'' Locate an array by virtual address in the shared memory source
'' used to veryify a valid address is passed
Private Sub locateByAddress(Virt As Pointer) As Pointer

    Dim result As Pointer = Null

    For Each mBlock As Variant In VarMem
        If mBlock.type = CshmArray
            If mBlock.VirtAddress = virt Then
                result = mBlock.VirtAddress
                Break
            Endif
        Endif
    Next

    Return result

End

'' Assign  this list to another variable, This is required to assign
'' shmobjects to the symbol table
Public Sub _Assign(VEntry As DPointer)

    If ArrayDef = Null Then
        vEntry.value = Null                                    ' if the listhead is valid then continue
    Else
        vEntry.Value = ArrayDef.Address        '  Assign this to the variable
    Endif

End

''  Release all memory when all ref is lost
Public Sub _free()

    Return

End

'' free the Array, delete all values, delete all elements, array header
Public Sub free()

    If ArrayDef = Null Or If varmem = Null Then Return
    clear()

    sem_destroy(VarMem.RealDataAddress(ArrayDef.sema))                   '' destroy the semphore
    VarMem.Free(ArrayDef.sema)                                                                       '' free its memory
    varmem.Free(ArrayDef.DataAddress)                                                         '' free the array index memory
    VarMem.Free(ArrayDef.Address)                                                                 '' free the array definition memory
    ArrayDef = Null                                                                                                   '' mark this object as invalid
    Varmem = Null                                                                                                     '' release the varmem

End

'' clear the content of the array
Public Sub clear()

    Dim PhysAddr As Pointer

    If ArrayDef = Null Then Return

    PhysAddr = VarMem.RealDataAddress(ArrayDef.DataAddress)     ' Get a pointer to the real memory array of pointers
    For i As Integer = 0 To ArrayDef.Count - 1
        Dim memptr As Pointer
        memptr = Pointer@(PhysAddr)                                '' get the Virtual address of the data
        If memptr <> Null Then
            varmem.free(memptr)                                                 '' free the variable data
            Pointer@(PhysAddr) = Null                                        '' mark the slot as empty
        Endif
        PhysAddr += SizeOf(gb.pointer)                             '' move to the next slot
    Next

End

'' Iterate through the array and return occupied or all cells only
'' based upon the iterate all property.
Public Sub _next() As Variant

    Dim PhysAddr As Pointer

    If IsNull(Enum.Index) Then
        Enum.Index = 0
    Else
        Inc Enum.Index
    Endif

TryAgain:

    If Enum.index >= ArrayDef.Count Then
        Enum.Stop()
        Return
    Endif

    $key = LinearToSubScript(Enum.index)
    PhysAddr = VarMem.RealDataAddress(ArrayDef.DataAddress)                                        ' Get a pointer to the real memory array of pointers
    PhysAddr += Enum.Index * SizeOf(gb.pointer)
    PhysAddr = Pointer@(PhysAddr)                                                                                                  ' get the virtual address of the value

    If PhysAddr = Null Then
        If $IterateAll Then
            Return DefaultValue
        Else
            Inc Enum.Index
            Goto TryAgain
        Endif
    Else
        Return VarMem[PhysAddr]                                                                                                          ' get the value from that virtual address
    Endif

End

''  Lock the Array  while processing the request
'' This is not automatic, the user must do this if required
Public Sub {lock}() As Boolean

    Dim result As Integer = -1
    Dim retrycounter As Long = 10

    If Not $UseLock Then Return True

    If ArrayDef = Null Then
        Error.Raise("ShmArray - invald Refrence")
    Endif

    While result <> 0
        result = sem_trywait(SemAddress)
        If result <> 0 Then
            Wait 0.0001
            Dec RetryCounter
            If retryCounter < 4 Then
                If ArrayDef.bDebug Then Print Application.id, "ShmArray Locking Race condition attempting fix ";; retryCounter
                Me.unlock()
            Endif
        Else
            Return True
        Endif
    Wend
    If ArrayDef.bDebug Then Print Application.id, "ShmArray Locking Race condition attempt to fix failed";; retryCounter
    Return False

End

''  Release the lock on the Array
'' Returns false if the lock was not 0, locked
'' be careful as this can be posted anywhere

Public Sub {unlock}() As Boolean

    If Not $UseLock Then Return True

    If ArrayDef = Null Then
        Error.Raise("ShmArray - invald Refrence")
    Endif

    Dim value As Integer = 0
    Dim iptr As Pointer = VarPtr(value)

    If sem_getvalue(SemAddress, iptr) = 0 Then
        If value = 0 Then
            sem_post(SemAddress)
            Return True
        Endif
    Endif
    Return False

End

'' convert the dimensions into a linear pointer
Public Sub GetOffset(Dims As Variant[], Optional SingleIndex As Long) As Pointer

    Dim realptr As Pointer = 0
    Dim position As Long = 0
    Dim factor As Long = 1

    If SingleIndex Or If Dims.count = 1 Then
        If Dims[0] < 0 Or If Dims[0] > ArrayDef.count - 1 Then
            Error.Raise("ShmArray : Out of bounds, must be  : 0-" & Str(ArrayDef.Count - 1))
        Else
            position = Dims[0]
        Endif
    Else
        If Dims.count <> ArrayDef.DimCount Then
            Error.Raise("ShmArray : Invalid dimesions count on access, given " & Dims.count & " , Needed  " & ArrayDef.dimcount)
        Endif

        For i As Long = 0 To ArrayDef.DimCount - 1
            If Dims[i] < 0 Or If Dims[i] >= ArrayDef.dimensions[i] Then
                Error.Raise("ShmArray : invalid array subscript :" & Str(Dims[i]) & ",expected  0 to " & Str(ArrayDef.dimensions[i] - 1) & ", At Subscript " & Str(i))
            Endif

            position += factor * Dims[i]
            factor *= ArrayDef.dimensions[i]

        Next
    Endif

    Position *= SizeOf(gb.pointer)

    RealPtr = VarMem.RealDataAddress(ArrayDef.DataAddress)                                        ' Get a pointer to the real memory array of pointers
    RealPtr += Position                                                                                                                        ' Get the correct virtual address
    Return RealPtr                                                                                                                                 ' return the virtual address of the variable assogned to this element

End

'' Translate the linear address Of the element To the correct position subscripts
Public Sub LinearToSubScript(Position As Long) As Long[]

    Dim result As New Long[arrayDef.DimCount]
    Dim factor As New Long[ArrayDef.dimCount]
    ' calculate the factors first
    factor.first = 1
    '  Result.last = Position % factor.last

    For i As Integer = 1 To factor.max
        factor[i] = ArrayDef.dimensions[i] * factor[i - 1]
    Next

    '                 position += factor * Dims[i]
    '                 factor *= ArrayDef.dimensions[i]

    For i As Integer = factor.max DownTo 0
        result[i] = position \ factor[i]
        position -= (position \ factor[i]) * factor[i]
    Next
    Return result

End

'' Put a vaulue into the array.
'' must have an index of integer to get debugger
'' to display elements
Public Sub _put(Value As Variant, index As Integer, ...)

    Dim dims As New Long[]

    dims.Add(index)
    dims.Insert(Param.all)
    PutValue(value, dims)

End

Private Sub PutValue(value As Variant, where As Long[])

    If arrayDef = Null Then Return
    Dim MemPtr As Pointer
    Dim RealPtr As Pointer

    Me.lock()
    realptr = GetOffset(where)                                             ' get the offset within our memory area
    memptr = Pointer@(realPtr)                                           ' get the virtual address of the dpointer variable
    If memptr = Null Then
        Pointer@(RealPtr) = varmem.set(value)                 ' allocate a new variable in memory
    Else
        varmem[memptr] = value                                            ' store the data at this location
    Endif

Finally
    Me.unlock()

End

'' get a value from the array
'' must have an index of integer to get debugger
'' to display elements
Public Sub _get(index As Integer, ...) As Variant

    Dim dims As New Long[]

    dims.Add(index)
    dims.Insert(Param.all)
    Return GetValue(dims)

End

Private Sub GetValue(where As Long[]) As Variant

    If arrayDef = Null Then Return Null

    Dim RealPtr As Pointer = 0
    Dim MemPtr As Pointer
    Dim Value As Variant

    Me.lock()

    realPtr = GetOffset(where)                                             ' get the offset within our memory area
    memptr = Pointer@(realPtr)                                           ' get the virtual address of the dpointer variable

    If memptr = Null Then
        Value = DefaultValue                                                    ' return the default dummy value
    Else
        Value = varmem[memptr]                                           ' retrieve the data at this location
    Endif

    Me.unlock()

    Return value

Catch
    Dim errormsg As String = Error.text & ", " & Error.where
    Me.unlock()
    Error.Raise(errormsg)

End

'' create a deep copy of the array
Public Sub {Copy}(Optional tag As String = "") As ShmArray

    Dim Source As ShmArray = Me
    Dim vArgs As New Variant[]

    If tag = "" Then tag = Source.tag
    Dim newShmArray As New ShmArray(varmem, ArrayDef.dimensions.Copy(0, ArrayDef.dimcount), tag)

    For Each vVal As Variant In Source
        vArgs.Clear()
        vArgs.Add(vval)
        vArgs.Insert($key, 1)
        Object.Call(newShmArray, "_put", vargs)
    Next
    Return NewShmArray

End

'' Returns the array content As A coma seperated string Array
'' this will not work as expected on an array of objects
'' Will return an error if array has more than two dimensions
Public Sub ToCvs() As String[]

    Dim i As Integer
    Dim rowVals As New Variant[]
    Dim Result As New String[]

    If ArrayDef.DimCount > 2 Then
        Error.Raise("ShmArray : too many dimensions to convert to cvs Max 2")
    Endif
    If ArrayDef.DimCount = 1 Then
        rowVals.Add(GetRow())
    Else
        For i = 0 To Me.submax[0]
            rowVals.Add(GetRow(i))
        Next
    Endif
    For i = 0 To rowVals.max
        result.Add(ToCvsText(rowVals[i]))
    Next

    Return result

End

'' Load an array from the provided cvs blob, row must be seperated by \n
'' if row count or col count is > or < then array dimensions then
'' < remander is not populated
'' > then remainder of data is ignored
Public Sub fromCvs(value As String)

    Dim lines As String[]

    If ArrayDef.DimCount > 2 Then
        Error.Raise("ShmArray : too many dimensions to convert from cvs Max 2")
    Endif

    Lines = Split(value, "\n", "\"", False, True)
    fromCvsText(Lines)

End

'' convert the rows to actual value array
Private Sub ToCvsText(value As Variant[]) As String

    Dim result As String = ""

    If value.count = 0 Then Return ""
    result &= IIf(TypeOf(value[0]) = gb.string, Quote(value[0]), value[0])
    For i As Integer = 1 To value.Max
        result &= ","
        result &= IIf(TypeOf(value[i]) = gb.string, Quote(value[i]), value[i])
    Next

    Return result

End

'' Reads a 1d or 2d array content from the
'' provided cvs file blob
Private Sub fromCvsText(value As String[])

    Dim result As New Variant[]
    Dim row As New Variant[]
    Dim items As String[]
    Dim vEval As Variant

    For i As Integer = 0 To value.max
        row = New Variant[]
        items = Split(value[i], ",", "\"", False, True)
        For Each s As String In items
            vEval = Eval(s)
            row.Add(vEval)
        Next
        result.Add(row)
    Next

    For i = 0 To Me.submax[0]
        If i > Result.max Then Break
        For j As Integer = 0 To Me.submax[1]
            If j > Result[i].max Then Break
            Me[i, j] = Result[i][j]
        Next
    Next

End

'' export  the assigned values, array size
'' the array is exported completely, with information required to
'' recreate the array, or reload the array
Public Sub {Export}() As String

    Dim vValue As Variant
    Dim i As Integer
    Dim Index As Long = 0

    If ArrayDef = Null Then Return ""
    Dim result As String = Subst("&1:&2", ArrayDef.Count, FormatDim(ArrayDef.dimensions.Copy(0, ArrayDef.DimCount))) & "\n"

    ' we only output value that have been defined
    Dim PhysAddr As Pointer
    PhysAddr = VarMem.RealDataAddress(ArrayDef.DataAddress)     ' Get a pointer to the real memory array of pointers
    For i As Integer = 0 To ArrayDef.Count - 1
        Dim memptr As Pointer
        memptr = Pointer@(PhysAddr)                                ' get the Virtual address of the data
        If memptr <> Null Then
            vValue = varmem[memptr]
            If TypeOf(vValue) = gb.string Then vValue = Quote(vValue)
            result &= Subst("&3:&1:&2\n", FormatDim(LinearToSubScript(index)), Str(vValue), Format(index, "000000"))
        Else
            result &= Subst("&3 :&1 : &2\n", FormatDim(LinearToSubScript(index)), Str(DefaultValue), Format(index, "000000"))
        Endif
        Inc index
        PhysAddr += SizeOf(gb.pointer)                             ' move to the next slot
    Next
    Return result

End

'' import data into a new array, the data me resize the array
'' all exsisting data in the array is lost
'' header format             : elementCount;sub1,sub2,sub3,..sub9 <- elementCount must match the number of total elements defined by the subscript or -1 not used
'' each element format : index:sub1,...:data expression <- the index should match the actual index into the linear space speed import or -1 not used
Public Sub Import(data As String)

    Dim dataset As String[] = Split(data, "\n", "\"", True, True)
    Dim working As String[] = Split(dataset[0], ":", "[]", True, False)
    Dim value As Variant
    Dim RealPtr As Pointer

    If working.count <> 2 Then
        Error.Raise("Import Header invalid: format = elementCount;sub1,sub2,sub3,..sub9\n")
    Endif
    Dim dims As Long[] = Eval("[" & working[1] & "]")
    ReDim(dims)
    Me.lock()
    For i As Integer = 1 To dataset.Max
        working = Split(dataset[i], ":", "\"", True, True)
        dims = Eval(working[1])
        value = Eval(working[2])
        realptr = GetOffset(dims)                                       ' get the offset within our memory area
        Pointer@(RealPtr) = varmem.set(value)                      ' allocate a new variable in memory
    Next

Finally
    Me.unlock()

End

'' Format the dimentions into a correct text representation
Public Sub FormatDim(dims As Long[]) As String

    Dim result As String = "[" & Format(dims[0], "000000")

    For i As Integer = 1 To dims.Max
        result &= "," & Format(dims[i], "000000")
    Next
    result &= "]"
    Return result

End

'' Get the values in the selected row
'' iterates over the last subscript  in an array definition  and returns the value
Public Sub GetRow(...) As Variant[]

    Dim result As New Variant[]
    Dim i As Integer
    Dim physAddr As Pointer

    If Param.count <> ArrayDef.Dimcount - 1 Then
        Error.Raise("Get row must specifiy all Sub scripts except the last one, needed : " & Str(ArrayDef.DimCount - 1) & ", Got " & Str(Param.count))
    Endif

    For i = 0 To Me.SubMax[ArrayDef.DimCount - 1]                              ' the last row
        Dim dimset As Long[] = Param.All
        dimset.Add(i)
        physAddr = GetOffset(dimset)
        physAddr = Pointer@(physAddr)
        If physaddr = 0 Then
            result.Add(defaultValue)
        Else
            result.Add(varmem[physaddr])
        Endif
    Next

    Return result

End

'' Get a single column value from the array
'' Provide the subscripts of the columns, the value for the col wanted is ignored
'' provide the subscript number of col wanted , 0 based number
Public Sub GetCol(SubscriptWanted As Integer, ...) As Variant[]

    Dim Result As New Variant[]
    Dim dimset As Long[] = Param.All
    Dim PhysAddr As Pointer

    For i As Integer = 0 To Me.SubMax[SubscriptWanted]
        dimset[SubScriptWanted] = i
        physAddr = GetOffset(dimset)
        physAddr = Pointer@(physAddr)
        If physaddr = 0 Then
            result.Add(defaultValue)
        Else
            result.Add(varmem[physaddr])
        Endif
    Next

    Return Result

End

'' Returns the linear count of elements in the array
Private Function Count_Read() As Long

    If arrayDef = Null Then Return 0
    Return ArrayDef.Count

End

'' Returns the linear count of elements in the array
Private Function length_Read() As Long

    If arrayDef = Null Then Return 0
    Return ArrayDef.Count

End

'' Returns the max Linear count of elements in the array
Private Function Max_Read() As Long

    If arrayDef = Null Then Return 0
    Return ArrayDef.count - 1

End

'' returns an array of subscripts in the array
Private Function Dimensions_Read() As Long[]

    If arrayDef = Null Then Return Null
    Return ArrayDef.dimensions.Copy(0, ArrayDef.DimCount)

End

'' Returns the arrays dimensions needs more work to be correct
'' needs to be re written
Private Function Bounds_read() As Integer[]

    Dim dims As Integer[] = Dimensions_Read()
    Dim a As Variant = Object.New("integer[]", dims)

    Return a

End

'' returns the virtual memory address of the data portion of the array
'' the data portion is an array of pointers to the users data
Private Function Address_Read() As Pointer

    If arrayDef = Null Then Return Null
    Return ArrayDef.DataAddress + SizeOf(dPointer)

End

'' returns an array of max indexes for each subscript in the array
Private Function SubMax_Read() As Long[]

    If arrayDef = Null Then Return Null
    Dim result As New Long[]

    For i As Long = 0 To ArrayDef.DimCount - 1
        result.Add(ArrayDef.dimensions[i] - 1)
    Next

    Return result

End

'' Returns the default value for the array
Private Function Default_Read() As Variant

    If arrayDef = Null Then Return 0
    Return DefaultValue

End

'' writes the default value for the array
Private Sub Default_Write(Value As Variant)

    If arrayDef = Null Then Return
    DefaultValue = value

End

'' Returns the number of elements in the array
Private Function Value_Read() As Variant

    If arrayDef = Null Then Return 0
    Return ArrayDef.Count

End

'' returns the virtual address of the Array control block
Private Function VirtAddress_Read() As Pointer

    Return VirtualAddress

End

'' Get the Tag associated with this array
Private Function Tag_Read() As String

    Return ArrayDef.Tag.ToString()

End

'' write a tag string to the array
Private Sub Tag_Write(Value As String)

    ArrayDef.tag = Byte[].FromString(Value)

End

'' Get the Type Ie.ShmArray Of this object, used
'' by the ShmMem Variable Handler
Private Function Type_Read() As Integer

    Return ArrayDef.type

End

'' set or reset if iteration should return every cell
'' or just those that have been set to a value
'' when set the default value for cells is returned for empty
'' cells
Private Function IterateAll_Read() As Boolean

    Return $IterateAll

End

'' set or reset if iteration should return every cell
'' or just those that have been set to a value
'' when set the default value for cells is returned for empty
'' cells
Private Sub IterateAll_Write(Value As Boolean)

    $IterateAll = value

End

'' Reads if Locking is used during array access
Private Function UseLock_Read() As Boolean

    Return $UseLock

End

'' Sets or resets if Locking is used during array access
Private Sub UseLock_Write(Value As Boolean)

    $Uselock = value

End

Private Function First_Read() As Variant

    Dim a As Long[] = ArrayDef.dimensions.Copy(0, ArrayDef.DimCount)

    For i As Integer = 0 To a.Max
        a[i] = 0
    Next
    Return GetValue(a)

End

Private Function Last_Read() As Variant

    Return GetValue(Me.submax)

End

Private Function Dim_Read() As Integer

    Return ArrayDef.DimCount

End

Static Public Sub _convert(VarStorage As Variant, ary As Variant) As ShmArray

    Dim result As ShmArray
    Dim Params As New Variant[]
    Dim vVarmem As Variant

    If Ary Not Is Array Then
        Return Null
    Endif

    If Object.Class(VarStorage).name == "ShmMem" Then
        vVarMem = VarStorage.MyVarMem
    Else
        vVarMem = VarStorage
    Endif

    Dim dims As New Long[Ary.bounds.count]
    For i As Integer = 0 To Ary.bounds.count - 1
        dims[i] = Ary.bounds[i]
    Next
    Params.add(vvarmem)
    Params.add(dims)
    result = Object.New("ShmArray", Params)
    dims.Fill(0)
    result._InitFrom(ary, 0, ByRef dims)

    Return result

End

Public Sub _InitFrom(ary As Variant, SubIndex As Integer, ByRef dims As Long[])

    Dim Value As Variant
    Dim SubMax As Long[] = Me.SubMax

    For i As Integer = 0 To submax[SubIndex]
        If SubIndex = dims.max Then
            dims[SubIndex] = i
            value = Object.Call(ary, "_get", dims)
            PutValue(value, dims)
        Else
            dims[SubIndex] = i
            _InitFrom(ary, SubIndex + 1, Dims)
        Endif
    Next

End

Private Function MemoryPool_Read() As ShmVarStorage

    Return VarMem

End
