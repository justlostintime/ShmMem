' Gambas class file

' Author Westwood JustLostintime
'Released Under:
'  GNU GENERAL Public LICENSE
'  Version 3, 29 June 2007
'  See project license file.

Export

'Fast Unsafe

Const VarMemDefault As Long = 2000000                                '' default memory size is 2 meg
Const MaxSymbolsDefault As Integer = 8000                          '' default variable memory space 8000 entries
Const TimeOutDefault As Float = 0.1                                          '' Default sem timeout

Public varStore As ShmMemBlock                                               '' the pysical memory segment being shared
Public varMnge As ShmManage                                                    '' the Object resposible to managing the raw memory
Public MyVarMem As ShmVarStorage                                        '' manages the actual values stored into the shared memory
Public VarStoreName As String                                                     '' The name for named memory

Public symStore As ShmMemBlock                                               '' the Raw memory used to store the symbol table
Public vars As ShmSymbolTable                                                    '' the object which will manage symbol table
Public SymStoreName As String                                                    '' the name of the symbol table for the named memory

Property Read Count As Integer                                                     '' number of symbols
Property Read Max As Integer                                                         '' Max index into the list
Property Read Length As Integer                                                    '' number of entries in the list
Private $sKey As String                                                                       '' text key
Property Read Key As String                                                             '' returns the index of the current entry in for next
Property Debug As Boolean Use $bDebug                                   '' Turns on and off the Debug messages
Property DefaultDirectory As String Use $sDefaultDirectory '' the default directiry used to save and load Images and variables
Property Signature As String Use $Signature                             '' Used to reconstitute co correct object shmmem in an application
Static Public objects As New Collection(gb.ignorecase)          '' The list of instanciations of the class

'' We need to determine if the object is a class=module or object=class instanciated object
'' This function correctly retruns the class for both objects and modules
Static Public Sub GetObjectClass(BasicObject As Object) As Class

    Dim result As Class = Object.Class(BasicObject)

    If result.Name == "class" Then
        Return BasicObject
    Else
        Return result
    Endif

End

'' Get a list Of every block Of the type
Static Public Sub GetListType(mVarmem As ShmVarStorage, itype As Integer) As Variant

    Dim ListTable As New Variant[]

    If mVarmem = Null Then Return ListTable
    For Each mBlock As Variant In mVarMem
        If mBlock.type = iType Then
            ListTable.Add(mBlock)
        Endif
    Next

    Return ListTable

End

'' Remove the Shared memory segment  by force
Static Public Sub ForceDelete(SharedName As String)

    Try shmMemBlock.ForceDelete(SharedName & "_Data")
    Try shmMemBlock.ForceDelete(SharedName & "_Symbols")

End

'' Look for the correct signature and return the appropriate match
'' if not found then return the default memory object
'' return null if not found
'' Locate a shared memory block by signature as an object
'' This will be used by the _read functions in the Shm Classes to locate
'' the correct memory block in which to instanciate the shmclass
Static Public Sub GetMemSegment(sSignature As String) As ShmMem

    Dim seg As Shmmem = objects[sSignature]

    If seg = Null Then
        seg = objects["default"]
        If seg <> Null Then
            Error "Shmmem Warning :"; sSignature;; "not found using default";; seg.Signature
        Endif
    Endif
    Return seg

End

'' Allocate the memory and symbol table. initialize structures
Public Sub _new(Optional VarMemLength As Variant = VarMemDefault, MemName As String = "", MaxSymbols As Integer = MaxSymbolsDefault, LockTimeOut As Float = TimeOutDefault)

    $sDefaultDirectory = User.home &/ "vars"

    If TypeOf(VarMemLength) = gb.string Then
        MemName = VarMemLength
        VarMemLength = VarMemDefault
    Endif

    If MemName <> "" Then
        VarStoreName = Memname & "_Data"
        SymStoreName = Memname & "_Symbols"
        $Signature = MemName & ":" & Application.version

        VarStore = New ShmMemBlock(VarMemLength, VarStoreName, LockTimeOut)
        SymStore = New ShmMemBlock((ShmSymbolTable.SymbolLength() * MaxSymbols) + ShmSymbolTable.InfoLength(), SymStoreName, LockTimeOut)
    Else
        VarStoreName = ""
        SymStoreName = ""
        $Signature = Application.name & ":" & Application.version
        VarStore = New ShmMemBlock(VarMemLength, MemName, LockTimeOut)
        VarStore.Signature = $Signature
        SymStore = New ShmMemBlock((ShmSymbolTable.SymbolLength() * MaxSymbols) + ShmSymbolTable.InfoLength(), MemName, LockTimeOut)
        SymStore.Signature = $Signature
    Endif

    VarMnge = New ShmManage(varStore)
    VarMnge.Signature = $Signature
    MyVarMem = New ShmVarStorage(varMnge)
    MyVarMem.Signature = $Signature
    Vars = New ShmSymbolTable(symStore, MyVarMem)
    Vars.Signature = $Signature
    If Shmmem.Objects.count = 0 Then
        shmMem.objects.Add(Me, "default")
    Endif
    shmMem.objects.Add(Me, $Signature)

End

'' Free the shared memory when the application closes
Public Sub _free()

    shmMem.objects.Remove(Me.Signature)

    Vars._free()
    Vars = Null

    MyVarMem._free()
    MyVarMem = Null

    varMnge = Null

    SymStore._free()
    SymStore = Null

    varstore = Null

End

'' map the symbol names to a property entry
Public Sub _property(...) As Boolean

    Debug "Param.count ="; Param.count
    Dim result As Boolean = True
    Return result

End

'' alway create a new symbol when  not know, save value otherwise
Public Sub _unknown(...) As Variant

    If Param.count = 0 Then                        ' if there are no parameters then assume it is a read value
        Return _get(Param.name)
    Endif
    ' otherwise we have to create the value entry
    If Param[0] Is Array Then
        Dim value As ShmArray
        Value = ShmArray._convert(Me, Param[0])
        _put(Value, Param.name)
    Else
        _put(Param[0], Param.name)
    Endif

End

'' return the value of a symbol
Public Sub _get(SymName As String, ...) As Variant

    Dim result As Variant

    result = vars[SymName]
    Return result

End

'' Store a value into a symbol
Public Sub _put(value As Variant, SymName As String, ...)

    Dim params As New Variant[]

    If Param.count > 0 Then
        Dim tmpvar As Variant = vars[SymName]
        params.add(value)
        params.Insert(Param.all)
        Object.Call(tmpvar, "_put", Params)
        vars[SymName] = tmpvar
    Else
        ' otherwise we have to create the value entry
        If TypeOf(Value) = gb.object And If value Is Array Then
            Dim nvalue As ShmArray
            nValue = ShmArray._convert(Me, Value)
            vars[SymName] = nValue
        Else
            vars[SymName] = value
        Endif
    Endif

End

'' remove a sysmbol from the symbol table and release all memory/values
Public Sub {Free}(SymName As Variant)

    Select Case TypeOf(SymName)
        Case gb.integer, gb.pointer, gb.long, gb.Short
            MyVarMem.FreeVirt(CPointer(SymName))
        Case gb.string
            vars.Free(SymName)
    End Select

End

''-----------------------------------------------------------------------------------
'' Read and write images and variables
''-----------------------------------------------------------------------------------
Public Sub SetPath(filePath As String, Optional defaultBaseName As String = "", defaultExtension As String = "") As String

    Dim basename As String = File.BaseName(filePath)
    Dim Extension As String = File.Ext(filePath)
    Dim Directory As String = File.Dir(filepath)

    If directory = "" Then directory = $sDefaultDirectory
    If basename = "" Then basename = defaultBaseName
    If extension = "" Then extension = defaultExtension
    Return Directory &/ basename & IIf(extension <> "", "." & Extension, "")

End

'' Writes a copy of the shared memory storage and symbol table to a file
Public Sub SaveImage(Optional FileName As String = Application.name & ".image")

    Dim outfileName As String = SetPath(FileName)
    Dim outfile As File

    Try outfile = Open outfilename For Write Create
    If Error Then
        Error.propegate()
    Endif
    vars.Save(outfile)
    Close outfile

End

'' Saves a copy of a symbol and its value to a file
Public Sub SaveVar(VarName As String, Optional filename As String = "")

    Dim outfileName As String = SetPath(FileName, VarName, "var")
    Dim outfile As File

    Try outfile = Open outfilename For Write Create
    If Error Then
        Error.propegate()
    Endif
    vars.SaveVar(VarName, Outfile)
    Close outfile

End

'' Load an image of the memory from disk and load it into the memory segment/Symbol table
Public Sub LoadImage(Optional FileName As String = Application.name & ".image")

    Dim infileName As String = SetPath(FileName)
    Dim infile As File

    Try infile = Open infilename For Read
    If Error Then
        Error.propegate()
    Endif
    vars.Load(infile)
    Close infile

End

'' Loads An individual Variable From a file
Public Sub LoadVar(FileName As String, Optional SymName As String = "")

    Dim infileName As String = SetPath(FileName, "", "var")
    Dim infile As File

    Try infile = Open infilename For Read
    If Error Then
        Error.Propagate()
    Endif
    vars.LoadVar(infile, SymName)
    Close infile

End

'' Returns a pointer to Symbols Value
Public Sub {VarPtr}(SymName As String) As Variant

    Return vars.VarPtr(SymName)

End

'' returns the size of memory needed to store a value
Public Sub {SizeOf}(Value As Variant) As Long

    Return MyVarMem.SizeOf(Value)

End

'' Prints a list of all Symbols and definition
Public Sub {Print}()

    Print vars.Text

End

'   Const VarMemDefault As Long = 2000000
'   Const MaxSymbolsDefault As Integer = 8000
'   Const TimeOutDefault As Float = 0.1
'
'   Public varStore As ShmMemBlock
'   Public varMnge As ShmManage
'   Public MyVarMem As ShmVarStorage
'
'   Public symStore As ShmMemBlock
'   Public vars As ShmSymbolTable
'   Public NotifyVars As ShmNotify
'' print all posible information about the shared memory
Public Sub PrintAllInfo(Optional Title As String = "")

    Print "***************************************** Full Memory Info " & title & "***************************************************"
    Print Subst("Default Memory Size &1MB, Max Symbol Table entries &2, Default Timeout &3", VarMemDefault / 1024, MaxSymbolsDefault, TimeOutDefault)
    Print
    Print Vars.text
    Print
    VarMnge._Print(MyVarMem)
    Print

End

'' Print a tree formated symbol table by hash bucket(not implemented)
Public Sub PrintTree()

    Print "not implemented"

End

'' Waitfor a symbol to be created, use notify on new instead
Public Sub WaitFor(SymName As String, Optional Timeout As Float = 0) As Boolean

    Return vars.WaitFor(symname, timeout)

End

'' spin wait for a symbol to have a specific value
Public Sub WaitForValue(SymName As String, Value As Variant, Optional Timeout As Float = 0) As Boolean

    Return vars.WaitForValue(symname, Value, timeout)

End

'' spin wait for a value to change, use notify instead
Public Sub WaitValueChange(SymName As String, Value As Variant, Optional Timeout As Float = 0) As Boolean

    Return vars.WaitValueChange(symname, Value, timeout)

End

'' Get a notification whenever a new symbol is created
Public Sub NotifyOnNew(Enabled As Boolean, NotifyObject As Object, Optional NotifyFunction As String = "") As Boolean

    Return vars.NotifyOnNew(enabled, NotifyObject, NotifyFunction)

End

'' Create a notification Event when ever the specified variable changes
Public Sub Notify(SymName As String, NotifyObject As Object, Optional NotifyFunction As String = "", Timeout As Float = 0, Tag As String = "")

    vars.Notify(SymName, NotifyObject, NotifyFunction, TimeOut, tag)

Catch
    Print "shm Notify :";; Error.text;; Error.where

End

'' Stop recieving notification for a symbol. Info must match the original notify call exactly
Public Sub NotifyStop(SymName As String, CallObject As Object, Optional CallFunc As String = "", Optional tag As String = "")

    vars.NotifyStop(SymName, CallObject, CallFunc, tag)

End

'' iterate through the list
Public Sub _next() As Variant

    Static SymList As String[]

    If Enum.Index = Null Then
        SymList = Vars.SortedList()
        If SymList.Count = 0 Then
            Enum.Stop()
        Endif
        Enum.index = 0
    Else
        Inc Enum.Index
        If Enum.index > SymList.max Then
            Enum.Stop()
            Return
        Endif
    Endif
    $sKey = SymList[Enum.index]
    Return Vars[SymList[Enum.Index]]

End

'' return true if a symbol exists else false
Public Sub Exist(SymName As String) As Boolean

    Return Vars.Exist(SymName)

End

'' Return the number of entries in the symbol table
Private Function Count_Read() As Integer

    Return Vars.count

End

'' retruns the max element index in the list
Private Function Max_Read() As Integer

    Return Vars.max

End

'' returns the number of elements in the symbol table
'' should be updated to return the actual entries available in the symbol table
Private Function Length_Read() As Integer

    Return vars.Count

End

'' Returns a list of all apps waiting for notification of a specific variable
Public Sub NotifyQ(symName As String) As ShmList

    If Not Vars.Exist(symname) Then
        Error.Raise("Unknown Symbol Name:" & Symname)
    Endif

    Return Vars.NotifyQ(symname)

End

'' Return the key symbol name In the For Next
Private Function Key_Read() As String

    Return $sKey

End

'' Returns the actual Physical address after traslating the Virtual pointer
Public Sub RealAddress(VirtAddress As Pointer) As Pointer

    MyVarMem.RealAddress(VirtAddress)

End

'' Allocate a block of memory
Public Sub {alloc}(Length As Pointer) As Pointer

    Dim TheMem As Pointer

    TheMem = MyVarMem.AllocVirt(Length)
    Return TheMem

End
