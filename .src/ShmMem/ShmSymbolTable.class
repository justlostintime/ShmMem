' Gambas class file

' Author Westwood JustLostintime
'Released Under:
'  GNU GENERAL Public LICENSE
'  Version 3, 29 June 2007
'  See project license file.

Export
Fast Unsafe

'' How a symbol is stored in the shared memory
Public Struct Symbol
    Name[128] As Byte                       '' Max length of any variable name actual length is 127 with terminating 0
    Used As Boolean                          '' This slot is in use
    NotifyBlock As Pointer               '' pointer to chain of pids waiting to be notified when This symbol changes
    Address As Long                          '' virtual address of the value, 0 means no value yet
    Hash As Long                                 '' Hash value for the symbol, used to match when collision
    NameLength As Integer              '' the length of the symbol Name
End Struct

'' The content of table structure and each entry in the symbol table
Public Struct TableInfo
    Initialized As Boolean                  '' indicates if memory must be initialized
    LastUpdate As Float                    '' The last time the table was updated
    Count As Long                               '' Number of actual table slots available
    Collisions As Long                         '' Number of times hash was already used
    UsedCount As Long                      '' Number of used Entries
    MaxCount As Long                        '' Max Number of entries ever used
    TotalRetryCount As Pointer       '' Max number of retries when looking for symols
End Struct

'' The structure of the actual symbol table, Virtual definition see Max default entries in ShmMem
'' This is never directly allocated. The max symbols defines the upper limit to the table length.
'' but this does not define the actual size or count when allocated. See shmmem  MaxSymbolsDefault
'' for the actual size of the table when it is created.
Public Struct tableLayout
    Table[20000] As Struct Symbol           '' fake number entries but does limit max number of symbols that can be defined in the sysmbol table during creation
End Struct

'' Used as a pointer to strings inside shared memory
Public Struct sString
    Value As String
End Struct

'' The value returned When there are no valid entries in table, not found, end of table, etc
Static Private NoEntry As Pointer = CPointer(-1)        '' &hffffffffff
Static Public MaxRehash As Integer = 100                        '' maximum times a rehash will be attempted when a colision happens

Public SymTblMem As ShmMemBlock
Public VarMem As ShmVarStorage
Public NotifyVars As ShmNotify
Public SymMem As TableLayout
Public SymInfo As TableInfo

'' cache the symbol names in a hash table for quick access
'' Does mean that we have to update this every time a symbol is added or removed .. lol
'' But this is a database not just a bunch of variables
Private SymbolCache As New Collection(gb.ignorecase) '' a collection of symbols since the last sym table update

Private LastUpdated As Float = 0                                            '' time stamp of the last time the Symbol Cache was updated

' Extern SymMemPtr(dest As Pointer, src As Pointer, Len As Integer) As TableLayout In "libc:6" Exec "memcpy"
' Extern SymInfoPtr(dest As Pointer, src As Pointer, Len As Integer) As TableInfo In "libc:6" Exec "memcpy"
' Extern memPtr(dest As Pointer, src As Pointer, Len As Integer) As Pointer In "libc:6" Exec "memcpy"
'Extern strncpy(dest As Pointer, source As String, len As Integer) As Pointer In "libc:6"
Extern strncmp(dest As Pointer, source As String, len As Integer) As Integer In "libc:6"

Property Read text As String                                '' Returns a printable representation of the symbol table
Property Read TextSummary As String             '' Returns a short summary of the symbol table"
Property Read count As Integer                           '' The number of active entries in the symbol table
Property Read Length As Integer                         '' The number of slots in the symbol table
Property Read Max As Integer                              '' The highest index that will work
Private $sKey As String
Property Read Key As String                                  '' The key when using for each
Private $vDefault As Variant = False
Property Default As Variant                                    '' The default value returned when a symbol does not exist, Defaults to False
Property Read MaxSymbols As Integer               '' The Max number of symbols that can be placed in the table
Property Read Collisions As Integer                      '' The number of time the Hash Function Collided with used entry
Property Read MaxUsedSymbols As Integer      '' Highest Number Of Symbols ever used
Property Debug As Boolean Use $bDebug          '' Turn on off the debug messages for this object

'' Save the contents of the symbol table to a file, The actual value of the symbol is also saved
'' Saves only the table entries that have an active symbol entry.
Public Sub Save(OutFile As File)

    If $bDebug Then Print Application.id, "Save SymTblmem.exclusive"
    SymTblMem.Exclusive()                                                              '' Lock the symbol table memory
    Write #outFile, SymInfo.UsedCount As Long
    Write #outFile, SymInfo.LastUpdate As Float
    For i As Integer = 0 To SymInfo.count - 1                               '' for each slot save to the file with the value
        If SymMem.Table[i].Used = False Then Continue             '' Skip unused entries
        If SymMem.Table[i].address > 0 Then
            Write #OutFile, True As Boolean                                      '' There is saved data
            WriteVar(SymMem.Table[i].Address, OutFile, SymMem.Table[i].Name.ToString())          '' Write the variable to the file
        Else
            Write #OutFile, False As Boolean                                     '' There is no data saved
        Endif
    Next

    SymTblMem.Release()                                                                 '' unlock the table access
    If $bDebug Then Print Application.id, "Save SymTblmem.release"

Catch
    Dim errormsg As String = "Save Error :" & Error.Text & "," & Error.where
    SymTblMem.Release()
    If $bDebug Then Print Application.id, "Save SymTblmem.release"
    Error.Raise(errormsg)

End

'' Write A Symbol/Variable to a file by name
Public Sub SaveVar(SymName As String, OutFile As File)

    UpdateCache()

    If Not SymbolCache.exist(SymName) Then
        Error.Raise("SaveVar Error:" & Error.text & "," & Error.where)
    Endif

    Dim index As Long = SymbolCache[SymName]
    WriteVar(SymMem.Table[index].Address, OutFile, SymName)
    If Error Then
        Error.Raise("SaveVar Error: " & Error.text & "," & Error.where)
    Endif

End

'' Write the variable/Symbol to a file by virtual memory reference
Public Sub WriteVar(Address As Long, OutFile As File, SymName As String)

    Dim value As Variant

    If $bDebug Then Print Application.id, "Save ShmSymbolTable VarMem.Lock " & SymName
    VarMem.Lock()
    value = VarMem[Address]
    Write #OutFile, SymName As String
    Write #OutFile, Value As Variant
    VarMem.Unlock()
    If $bDebug Then Print Application.id, "Save ShmSymbolTable Varmem.UnLock " & SymName
Catch
    Dim errormsg As String = "WriteVar Error :" & Error.text & "," & Error.where
    VarMem.Unlock()
    If $bDebug Then Print Application.id, "Save ShmSymbolTable Varmem.UnLock " & SymName
    Error.Raise(errormsg)

End

'' Load the complete previously saved Symbol table and symbol values.
Public Sub Load(InFile As File)

    Dim UsedCount As Long
    Dim lastUpdate As Float
    Dim Assigned As Boolean

    UsedCount = Read #inFile As Long
    lastUpdate = Read #inFile As Float
    For i As Integer = 1 To usedCount                           '' load all the variables
        Assigned = Read #inFile As Boolean
        If Not Assigned Then Continue
        LoadVar(inFile)
    Next

Catch
    Dim errormsg As String = "Load Error :" & Error.Text & "," & Error.where
    Error.Raise(errormsg)

End

'' Load a variable file by text name into the symbol table
Public Sub Loadvar(infile As File, Optional symname As String = "")

    ReadVar(infile, symname)

End

'' Read symbol value from a file, if the Symname does not match the
'' stored symbol name then rename the symbol to the
'' provided name. if the ReqSymName is blank then use the name from the file
Public Sub ReadVar(infile As File, ReqSymname As String)

    Dim symname As String
    Dim value As Variant

    Symname = Read #infile As String
    If reqSymname <> "" Then symname = ReqSymName
    value = Read #infile As Variant
    _put(value, symname)

End

'' return the length of a symbol table entry
Static Public Sub SymbolLength() As Integer

    Return SizeOf(symbol)

End

'' Return the length of the symbol table header
Static Public Sub InfoLength() As Integer

    Return SizeOf(TableInfo)

End

'' Create a new symbol table, provide the symbol table memory and
'' the Variable storgage information
Public Sub _new(MemBlock As ShmMemBlock, DataMem As ShmVarStorage)

    ' $bDebug = True

    VarMem = DataMem
    SymTblMem = MemBlock

    If $bDebug Then Print Application.id, "_new SymTblmem.exclusive"
    SymTblMem.Exclusive()

    ' SymMem = SymMemPtr(MemBlock.DataAddress + SizeOf(TableInfo), MemBlock.DataAddress + SizeOf(TableInfo), 0)
    SymMem = MemBlock.DataAddress + SizeOf(TableInfo)

    ' SymInfo = SymInfoPtr(MemBlock.DataAddress, MemBlock.DataAddress, 0)
    SymInfo = MemBlock.DataAddress

    If Not SymInfo.Initialized Then
        SymInfo.count = (SymTblMem.DataLength / SizeOf(Symbol)) - 10
        SymInfo.LastUpdate = Timer
        SymInfo.Initialized = True
        SymInfo.Collisions = 0
        SymInfo.MaxCount = 0
        SymInfo.UsedCount = 0
        SymInfo.TotalRetryCount = 0
    Endif

    LastUpdated = Timer

    SymTblMem.Release()
    If $bDebug Then Print Application.id, "_new SymTblmem.release"

    NotifyVars = New ShmNotify(VarMem)

    UpdateCache()

End

Public Sub _free()

    If varmem = Null Then
        Return
    Endif

    NotifyVars = Null
    varmem = Null
    SymTblMem = Null

End

'' update the apps/tasks copy of the symbol table
Private Sub UpdateCache()

    If LastUpdated = SymInfo.LastUpdate Then Return

    SymbolCache.Clear()

    For i As Integer = 0 To SymInfo.Count - 1
        If SymMem.Table[i].Used And SymMem.Table[i].Address > 0 Then
            SymbolCache.Add(i, SymMem.Table[i].Name.toString())
        Endif
    Next

    LastUpdated = SymInfo.LastUpdate

End

'' remove all the entries from the symbol table
Public Sub Clear()

    If $bDebug Then Print Application.id, "Clear SymTblmem.exclusive"
    SymTblMem.Exclusive()

    SymbolCache.Clear()

    For i As Integer = 0 To SymInfo.Count - 1
        If SymMem.Table[i].Used = True Then
            VarMem.Free(SymMem.Table[i].Address)
        Else
            Continue
        Endif
        SymMem.Table[i].Used = False
    Next

    SymInfo.UsedCount = 0
    LastUpdated = Timer
    SymInfo.LastUpdate = LastUpdated

    SymTblMem.Release()
    If $bDebug Then Print Application.id, "Clear SymTblmem.release"

End

'' rehash the the value, used when a collision occurs
Fast Unsafe Private Sub ReHash(oldHash As Pointer) As Pointer

    Dim value As Long = CLong(oldHash)

    Return (31 * Value + 51) Mod SymInfo.count

End

'' Hash table uses  pointers as index value  as they are unsigned
Fast Unsafe Private Sub Hash(Symbol As String) As Pointer

    Dim SymName As String = Lower(Symbol)
    Dim Buffer As Byte[]
    Dim Value As Long = 0
    Dim tblLen As Long = SymInfo.count

    Buffer = Byte[].FromString(SymName)
    For i As Integer = 0 To Buffer.Max
        Value = (31 * Value + Buffer[i]) Mod TblLen
    Next
    Return value

End

'' returns the table entry with this hash and symbol
'' optionally returns the next empty slot after this hash, search for empty if hash collision occurs
Fast Unsafe Private Sub FindHash(HashValue As Pointer, SymName As String, Optional NextEmpty As Boolean = False) As Pointer

    Dim index As Pointer = HashValue

    If SymMem.Table[index].Used = False Then
        If NextEmpty Then Return index
        Return NoEntry
    Endif

    If Not nextempty Then SymName = Lower(SymName)
    Dim MaxRetry As Integer = SymInfo.Count

    While True

        If Not NextEmpty And If SymMem.Table[index].Hash = hashValue Then                                                   '' if the hash values match then check actual name incase of collision
            Dim NameLen As Integer = SymMem.Table[index].NameLength
            If NameLen = SymName.len Then
                Dim cmpresult As Integer = strncmp(SymMem.Table[index].Name.data, SymName, NameLen)
                If cmpresult = 0 Then
                    Return index
                Endif
            Endif
        Endif

        If nextempty Then
            Inc SymInfo.Collisions                                              '' Number of collisions when adding a new variable
        Else
            Inc SymInfo.TotalRetryCount                                 '' Number of retry attempts when looking for a variable
        Endif

    Searchloop:
        Inc index
        If index = HashValue Then Break                               '' if we have looped through whole table then exit
        If index = SymInfo.count Then index = 0                  '' If we are at end of table then start at the top again

        If SymMem.Table[index].Used = False Then
            If NextEmpty Then Return index                            '' if we are looking for an empty slot return the index
            Goto Searchloop                                                         '' if we are looking for a variable skip empty slots
        Endif

    Wend

    Return NoEntry

End

Private Sub FindEmpty(HashValue As Pointer, Symbol As String) As Pointer     '' Returns the next available entry in the symbol table

    Return FindHash(HashValue, Symbol, True)

End

Public Sub GetSymIndex(Symbol As String) As Pointer

    Dim MyHash As Pointer = Hash(symbol)

    Return FindHash(MyHash, Symbol)

End

'' Return the slot number insert the name and change the lastupdated time
'' Create a basic variable storage to go along with this symbol
'' Update the virtual address of Var in the table
Public Sub Add(symName As String, value As Variant) As Long

    '    Dim result As Pointer

    If SymName = "" Then
        Error.Raise("Symbol name can not be blank")
    Endif

    Symname = Lower(symname)

    Dim HashValue As Pointer = Hash(symName)

    If $bDebug Then Print Application.id, "Add SymTblmem.exclusive " & SymName
    SymTblMem.Exclusive()

    Dim i As Pointer = FindEmpty(HashValue, SymName)

    If i = NoEntry Then
        SymTblMem.Release()
        Error.Raise("No More Room In Symbol Table : Used: " & SymInfo.UsedCount & ",Available:" & SymInfo.count & " for " & symname)
    Endif

    If $bDebug Then Print Application.id, "Add SymTblmem.Empty hash found " & SymName

    ' result = strncpy(SymMem.Table[i].Name.data, symname, 127)
    If symname.len > 127 Then symname = Left(symname, 127)
    Dim sNewSym As Byte[] = Byte[].FromString(symname)

    For j As Integer = 0 To sNewSym.max
        SymMem.Table[i].Name[j] = sNewSym[j]
    Next
    SymMem.Table[i].Name[j] = 0

    If $bDebug Then Print Application.id, "Add SymTblmem.Symbol name set  " & SymName

    SymMem.Table[i].NameLength = IIf(symname.len > 127, 127, symName.len)

    SymMem.Table[i].Hash = HashValue
    SymMem.Table[i].Used = True
    SymInfo.LastUpdate = Timer

    LastUpdated = SymInfo.LastUpdate
    SymbolCache[symName] = i

    SymMem.Table[i].Address = VarMem.set(value)

    Inc SymInfo.UsedCount
    If SymInfo.MaxCount < SymInfo.UsedCount Then
        SymInfo.MaxCount = SymInfo.UsedCount
    Endif

    SymTblMem.Release()
    If $bDebug Then Print Application.id, "Add SymTblmem.release"

End

Public Sub Remove(SymName As String)

    Dim freeData As Pointer

    UpdateCache()

    If Not SymbolCache.Exist(SymName) Then
        Error.Raise("Unknown Symbol " & SymName)
    Endif

    Dim index As Long = SymbolCache[SymName]

    If $bDebug Then Print Application.id, "remove SymTblmem.exclusive " & SymName
    SymTblMem.Exclusive()

    freeData = SymMem.Table[index].Address
    SymMem.Table[index].Address = NoEntry
    SymMem.Table[index].Used = False
    SymbolCache.Remove(SymName)
    SymInfo.LastUpdate = Timer
    LastUpdated = SymInfo.LastUpdate

    Dec SymInfo.UsedCount

    SymTblMem.Release()

    If $bDebug Then Print Application.id, "remove SymTblmem.release"
    VarMem.Free(Freedata)

End

Public Sub _get(SymName As String) As Variant

    UpdateCache()

    If Not SymbolCache.exist(SymName) Then
        Return $vDefault
    Endif

    Dim index As Long = SymbolCache[SymName]

    If $bDebug Then Print Application.id, "_get ShmSymbolTable VarMem.Lock " & SymName
    VarMem.Lock()
    Dim value As Variant = VarMem[SymMem.Table[index].Address]
    VarMem.Unlock()
    If $bDebug Then Print Application.id, "_get ShmSymbolTable Varmem.UnLock " & SymName
    Return value

End

Public Sub _put(value As Variant, SymName As String)

    UpdateCache()
    Dim SymbolIndex As Long
    Dim sym As Symbol

    If Not SymbolCache.Exist(SymName) Then
        Add(SymName, Value)
    Else

        SymbolIndex = SymbolCache[SymName]
        Sym = SymMem.Table[SymbolIndex]
        VarMem.Lock()
        VarMem[Sym.Address] = value
        VarMem.Unlock()
        If Sym.NotifyBlock <> 0 Then
            NotifyVars.SignalEach(Sym)
        Endif
    Endif

End

Public Sub Notify(SymName As String, CallBack As Object, Optional FuncName As String = "", Timeout As Long = 0)

    Dim ObjClass As Class = Null
    Dim SymbolIndex As Variant = SymbolCache[SymName]

    If Not SymbolIndex Then
        Error.Raise("Unknown Variable " & Quote(SymName))
    Endif
    If FuncName = "" Then funcName = SymName & "_Changed"

    Dim cClass As Class
    For Each cClass In classes
        If CallBack = cClass Then
            ObjClass = cClass
            Break
        Endif
    Next

    If IsNull(ObjClass) Then
        ObjClass = Object.Class(CallBack)
    Endif

    If ObjClass.Exist(FuncName) Then
        NotifyVars.Notify(SymMem.Table[SymbolIndex], CallBack, FuncName, Timeout)
    Else
        Error.Raise("Unknown Function Name " & FuncName)
    Endif

End

Public Sub NotifyStop(SymName As String)

    Dim SymbolIndex As Variant = SymbolCache[SymName]

    If Not SymbolIndex Then
        Error.Raise("Unknown Variable " & Quote(SymName))
    Endif
    NotifyVars.NotifyStop(SymMem.Table[SymbolIndex])

End

'' Returns the Virtual Address of the symbol
Public Sub {VarPtr}(SymName As String) As Variant

    UpdateCache()
    If Not SymbolCache.exist(SymName) Then
        Error.Raise("Unknow Symbol " & SymName)
    Else
        Dim index As Long = SymbolCache[SymName]
        Dim value As Variant = VarMem.varptr(SymMem.Table[index].Address)
    Endif

    Return value

End

''Returns a Virtual object pointing to the table entry
Public Sub Entry(SymName As String) As Variant

    UpdateCache()
    If Not SymbolCache.exist(SymName) Then
        Error.Raise("Unknow Symbol " & SymName)
    Else
        Dim index As Long = SymbolCache[SymName]
        Dim value As Variant = SymMem.Table[index]
    Endif

    Return value

End

Private Sub TextSummary_Read() As String

    Dim Result As String = ""

    Result &= "\nSymbol Table Listing\nMaxLength = " & SymInfo.MaxCount & ", Available Slots = " & SymInfo.Count & ", Occupied Slots = " & SymInfo.UsedCount &
        ",\nCollisions = " & SymInfo.Collisions & ", Search Retry count = " & SymInfo.TotalRetryCount &
        "\nLast Updated " & SymInfo.LastUpdate & ", Phy Address " & Hex(SymTblMem.MemoryAddress, 8) & "\n"

    Return result

End

Private Sub Text_Read() As String

    Dim Result As String = ""

    Result &= TextSummary_Read()

    For Each Var As Integer In SymbolCache
        Result &= Format(SymMem.Table[Var].Hash, "####0") & ":" & Left(SymMem.Table[Var].Name.ToString() & Space(25), 25) & " : " & VarMem.text(SymMem.Table[Var].Address) & "\n"
    Next
    Return result

End

Public Sub {Exist}(SymName As String) As Boolean

    UpdateCache()
    Return SymbolCache.Exist(SymName)

End

'' Wait for a variable to appear with timeout
Public Sub WaitFor(SymName As String, Optional Timeout As Float = 0) As Boolean

    Dim starttime As Float = Timer

    UpdateCache()

    While Not SymbolCache.Exist(symname)
        If timeout > 0 And If Timer - starttime >= timeout Then
            Return False
        Endif
        UpdateCache()
        Wait 0
    Wend
    Return True

End

Public Sub WaitForValue(SymName As String, Value As Variant, Optional timeout As Float = 0) As Boolean

    Dim starttime As Float = Timer

    UpdateCache()
    While Not SymbolCache.Exist(symname)
        If timeout > 0 And If Timer - starttime >= timeout Then
            Return False
        Endif
        UpdateCache()
        Wait 0
    Wend

    While Me[symname] <> Value
        Wait 0
        If timeout > 0 And If Timer - starttime >= timeout Then
            Return False
        Endif
    Wend

    Return True

End

Public Sub WaitValueChange(SymName As String, Value As Variant, Optional timeout As Float = 0) As Boolean

    Dim starttime As Float = Timer

    UpdateCache()
    While Not SymbolCache.Exist(symname)
        If timeout > 0 And If Timer - starttime >= timeout Then
            Return False
        Endif
        UpdateCache()
        Wait 0
    Wend

    While Me[symname] = Value
        If timeout > 0 And If Timer - starttime >= timeout Then
            Return False
        Endif
        Wait 0
    Wend

    Return True

End

'' Return a list of all symbols, Sorted by text name
Public Sub SortedList() As String[]

    Dim RetList As New String[]

    For i As Integer = 0 To SymInfo.Count - 1
        If SymMem.Table[i].Used And SymMem.Table[i].Address > 0 Then
            RetList.Add(SymMem.Table[i].Name.toString())
        Endif
    Next
    RetList.Sort()
    Return RetList

End

'' iterate through the symbol table in shared memory
'' return the next used slot in the list
Public Sub _next() As Variant

    If Enum.Index = Null Then
        If SymInfo.count = 0 Then
            Enum.Stop()
            Return
        Endif
        Enum.Index = NextUsedSlot(-1)
        $sKey = SymMem.Table[Enum.Index].Name.toString()
    Else
        Enum.index = NextUsedSlot(Enum.index)
        If Enum.index = -1 Then
            Enum.Stop()
            Return
        Endif
        $sKey = SymMem.Table[Enum.Index].Name.toString()
    Endif

    Return VarMem[SymMem.Table[Enum.index].Address]

End

'' Return the next used slot given the starting point to search
Private Sub NextUsedSlot(index As Long) As Long

    Inc index
    While Index < SymInfo.Count And SymMem.Table[index].Used = False
        Inc index
    Wend
    If Index >= SymInfo.Count Then
        index = -1
    Endif
    Return index

End

'' return the number of entries in the actual symbol table
Private Function count_Read() As Integer

    Return SymInfo.UsedCount

End

'' return the max number of last  symbol for iteration through the list
Private Function Max_Read() As Integer

    Return SymInfo.UsedCount - 1

End

'' The number of slots in the symbol table
Private Function Length_Read() As Integer

    Return SymInfo.Count

End

Private Function Key_Read() As String

    Return $sKey

End

Private Function Default_Read() As Variant

    Return $vDefault

End

Private Sub Default_Write(Value As Variant)

    $vDefault = Value

End

Private Function MaxSymbols_Read() As Integer

    Return SymInfo.Count

End

'' returns the number of collisions using the hash function
Private Function Collisions_Read() As Integer

    Return SymInfo.Collisions

End

'' return the highest number of sysmbols at any one time
Private Function MaxUsedSymbols_Read() As Integer

    Return SymInfo.MaxCount

End
