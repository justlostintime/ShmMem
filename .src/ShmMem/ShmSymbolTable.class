' Gambas class file

' Author Westwood JustLostintime
'Released Under:
'  GNU GENERAL Public LICENSE
'  Version 3, 29 June 2007
'  See project license file.

Export
'Fast Unsafe
'' How a symbol is stored in the shared memory

Public Struct Symbol
    Name[128] As Byte                       '' Max length of any variable name actual length is 127 with terminating 0
    Used As Boolean                          '' This slot is in use
    NotifyBlock As Pointer               '' pointer to chain of pids waiting to be notified when This symbol changes
    Address As Long                          '' virtual address of the value, 0 means no value yet, pointer to structures for internal shm extended data types
    Hash As Long                                 '' Hash value for the symbol, used to match when collision
    NameLength As Integer              '' the length of the symbol Name
    {Next} As Long                               '' in case of a hash conflict index to the next in this chain -1 of not used
    Previous As Long                           '' in case of hash conflict index to the parent of this value -1 if not used
    Type As Integer                              '' data type of the data stored into the memory, -1 if gambas data type
End Struct

'' The content of table structure and each entry in the symbol table
Public Struct TableInfo
    Initialized As Boolean                  '' indicates if memory must be initialized
    LastUpdate As Float                    '' The last time the table was updated
    Count As Long                               '' Number of actual table slots available
    Collisions As Pointer                     '' Number of times hash was already used
    UsedCount As Long                      '' Number of used Entries
    MaxCount As Long                        '' Max Number of entries ever used
    TotalRetryCount As Pointer       '' Max number of retries when looking for symols
    NotifyOnNew As Integer             '' set this when someone is waiting to be notified of var creation
End Struct

'' The structure of the actual symbol table, Virtual definition see Max default entries in ShmMem
'' This is never directly allocated. The max symbols defines the upper limit to the table length.
'' but this does not define the actual size or count when allocated. See shmmem  MaxSymbolsDefault
'' for the actual size of the table when it is created.
Public Struct tableLayout
    Table[80000] As Struct Symbol           '' fake number entries but does limit max number of symbols that can be defined in the sysmbol table during creation
End Struct

'' Used as a pointer to strings inside shared memory
Public Struct sString
    Value As String
End Struct

'' The value returned When there are no valid entries in table, not found, end of table, etc
Static Private NoEntry As Pointer = CPointer(-1)        '' &hffffffffff

Public SymTblMem As ShmMemBlock
Public VarMem As ShmVarStorage
Public NotifyVars As ShmNotify
Public SymMem As TableLayout
Public SymInfo As TableInfo

'' cache the symbol names in a hash table for quick access
'' Does mean that we have to update this every time a symbol is added or removed .. lol
'' But this is a database not just a bunch of variables
Public SymbolCache As New Collection(gb.ignorecase) '' a collection of symbols since the last sym table update

Private LastUpdated As Float = 0                                            '' time stamp of the last time the Symbol Cache was updated

' Extern SymMemPtr(dest As Pointer, src As Pointer, Len As Integer) As TableLayout In "libc:6" Exec "memcpy"
' Extern SymInfoPtr(dest As Pointer, src As Pointer, Len As Integer) As TableInfo In "libc:6" Exec "memcpy"
Extern memPtr(dest As Pointer, src As Pointer, Len As Integer) As Pointer In "libc:6" Exec "memcpy"
'Extern strncpy(dest As Pointer, source As String, len As Integer) As Pointer In "libc:6"
Extern strncmp(dest As Pointer, source As String, len As Integer) As Integer In "libc:6"

Property Read text As String                                                   '' Returns a printable representation of the symbol table
Property Read TextSummary As String                               '' Returns a short summary of the symbol table"
Property Read count As Integer                                             '' The number of active entries in the symbol table
Property Read Length As Integer                                           '' The number of slots in the symbol table
Property Read Max As Integer                                                '' The highest index that will work
Property Read Key As String Use $sKey                              '' The key when using for each
Property Read KeyIndex As Long Use $iKeyIndex            '' the index of the current entry in the symbol table
Property Default As Variant Use $vDefault = False          '' The default value returned when a symbol does not exist, Defaults to False
Property Read MaxSymbols As Integer                                '' The Max number of symbols that can be placed in the table
Property Read Collisions As Integer                                       '' The number of time the Hash Function Collided with used entry
Property Read MaxUsedSymbols As Integer                       '' Highest Number Of Symbols ever used
Property Debug As Boolean Use $bDebug                          '' Turn on off the debug messages for this object
Property UseCache As Boolean Use $UseCache = True    '' Trun on or off the use of the Cache for variables in local app

'' Save the contents of the symbol table to a file, The actual value of the symbol is also saved
'' Saves only the table entries that have an active symbol entry.
Public Sub Save(OutFile As File)

    If $bDebug Then Print Application.id, "Save SymTblmem.exclusive"
    SymTblMem.Exclusive()                                                              '' Lock the symbol table memory
    Write #outFile, SymInfo.UsedCount As Long
    Write #outFile, SymInfo.LastUpdate As Float
    For i As Integer = 0 To SymInfo.count - 1                               '' for each slot save to the file with the value
        If SymMem.Table[i].Used = False Then Continue             '' Skip unused entries
        If SymMem.Table[i].address > 0 Then
            Write #OutFile, True As Boolean                                      '' There is saved data
            WriteVar(SymMem.Table[i].Address, OutFile, SymMem.Table[i].Name.ToString())          '' Write the variable to the file
        Else
            Write #OutFile, False As Boolean                                     '' There is no data saved
        Endif
    Next

    SymTblMem.Release()                                                                 '' unlock the table access
    If $bDebug Then Print Application.id, "Save SymTblmem.release"

Catch
    Dim errormsg As String = "Save Error :" & Error.Text & "," & Error.where
    SymTblMem.Release()
    If $bDebug Then Print Application.id, "Save SymTblmem.release"
    Error.Raise(errormsg)

End

'' Write A Symbol/Variable to a file by name
Public Sub SaveVar(SymName As String, OutFile As File)

    Dim index As Long

    If $UseCache Then
        UpdateCache() ' updated
        If Not SymbolCache.exist(SymName) Then ' updated
            Error.Raise("SaveVar Error:" & Error.text & "," & Error.where)
        Endif
        index = SymbolCache[SymName]    ' updated
    Else
        index = GetSymbol(SymName)
        If index = noentry Then
            Error.Raise("SaveVar Error:" & Error.text & "," & Error.where)
        Endif
    Endif
    WriteVar(SymMem.Table[index].Address, OutFile, SymName)
    If Error Then
        Error.Raise("SaveVar Error: " & Error.text & "," & Error.where)
    Endif

End

'' Write the variable/Symbol to a file by virtual memory reference
Public Sub WriteVar(Address As Long, OutFile As File, SymName As String)

    Dim value As Variant

    If $bDebug Then Print Application.id, "Save ShmSymbolTable VarMem.Lock " & SymName
    VarMem.Lock()
    value = VarMem[Address]
    Write #OutFile, SymName As String
    Write #OutFile, Value As Variant
    VarMem.Unlock()
    If $bDebug Then Print Application.id, "Save ShmSymbolTable Varmem.UnLock " & SymName
Catch
    Dim errormsg As String = "WriteVar Error :" & Error.text & "," & Error.where
    VarMem.Unlock()
    If $bDebug Then Print Application.id, "Save ShmSymbolTable Varmem.UnLock " & SymName
    Error.Raise(errormsg)

End

'' Load the complete previously saved Symbol table and symbol values.
Public Sub Load(InFile As File)

    Dim UsedCount As Long
    Dim lastUpdate As Float
    Dim Assigned As Boolean

    UsedCount = Read #inFile As Long
    lastUpdate = Read #inFile As Float
    For i As Integer = 1 To usedCount                           '' load all the variables
        Assigned = Read #inFile As Boolean
        If Not Assigned Then Continue
        LoadVar(inFile)
    Next

Catch
    Dim errormsg As String = "Load Error :" & Error.Text & "," & Error.where
    Error.Raise(errormsg)

End

'' Load a variable file by text name into the symbol table
Public Sub Loadvar(infile As File, Optional symname As String = "")

    ReadVar(infile, symname)

End

'' Read symbol value from a file, if the Symname does not match the
'' stored symbol name then rename the symbol to the
'' provided name. if the ReqSymName is blank then use the name from the file
Public Sub ReadVar(infile As File, ReqSymname As String)

    Dim symname As String
    Dim value As Variant

    Symname = Read #infile As String
    If reqSymname <> "" Then symname = ReqSymName
    value = Read #infile As Variant
    _put(value, symname)

End

'' return the length of a symbol table entry
Static Public Sub SymbolLength() As Integer

    Return SizeOf(symbol)

End

'' Return the length of the symbol table header
Static Public Sub InfoLength() As Integer

    Return SizeOf(TableInfo)

End

'' Create a new symbol table, provide the symbol table memory and
'' the Variable storgage information
Public Sub _new(MemBlock As ShmMemBlock, DataMem As ShmVarStorage, Optional ActivateCache As Boolean = False)

    ' $bDebug = True

    $UseCache = ActivateCache
    VarMem = DataMem
    SymTblMem = MemBlock

    If $bDebug Then Print Application.id, "_new SymTblmem.exclusive"
    SymTblMem.Exclusive()

    SymMem = MemBlock.DataAddress + SizeOf(TableInfo)

    SymInfo = MemBlock.DataAddress

    If Not SymInfo.Initialized Then
        SymInfo.count = (SymTblMem.DataLength / SizeOf(Symbol)) - 10
        SymInfo.LastUpdate = Timer
        SymInfo.Initialized = True
        SymInfo.Collisions = 0
        SymInfo.MaxCount = 0
        SymInfo.UsedCount = 0
        SymInfo.TotalRetryCount = 0
    Endif

    LastUpdated = Timer

    SymTblMem.Release()
    If $bDebug Then Print Application.id, "_new SymTblmem.release"

    NotifyVars = New ShmNotify(VarMem, Me)

    If Not Me.Exist("#onnew") Then
        Me["#onnew"] = "Holding Queue for new symbol creation"
        SymInfo.NotifyOnNew = 0
        Dim index As Long = GetSymbol("#onnew")
        Dim sym As Symbol = SymMem.Table[index]
        Dim NotList As New ShmList(Varmem, 0, True, "On New Queue")
        sym.NotifyBlock = NotList.Address
    Endif

    If $UseCache Then UpdateCache()

End

Public Sub _free()

    SymTblMem = Null
    VarMem = Null
    NotifyVars = Null
    SymMem = Null
    SymInfo = Null

End

'' update the apps/tasks copy of the symbol table
Private Sub UpdateCache()

    If Not $UseCache Then
        Stop
    Endif

    If LastUpdated = SymInfo.LastUpdate Then Return

    SymbolCache.Clear()

    For i As Integer = 0 To SymInfo.Count - 1
        If SymMem.Table[i].Used And SymMem.Table[i].Address > 0 Then
            SymbolCache.Add(i, SymMem.Table[i].Name.toString())
        Endif
    Next

    LastUpdated = SymInfo.LastUpdate

End

'' remove all the entries from the symbol table
Public Sub Clear()

    If $bDebug Then Print Application.id, "Clear SymTblmem.exclusive"
    SymTblMem.Exclusive()

    If $UseCache Then SymbolCache.Clear()

    For i As Integer = 0 To SymInfo.Count - 1
        If SymMem.Table[i].Used = True Then
            VarMem.Free(SymMem.Table[i].Address)
        Else
            Continue
        Endif
        SymMem.Table[i].Used = False
    Next

    SymInfo.UsedCount = 0
    LastUpdated = Timer
    SymInfo.LastUpdate = LastUpdated

    SymTblMem.Release()
    If $bDebug Then Print Application.id, "Clear SymTblmem.release"

End

LastHash As Long
'' Hash table uses  pointers as index value  as they are unsigned

Private Sub Hash(Symbol As String) As Pointer

    Dim SymName As String = Lower(Symbol)
    Dim Buffer As Byte[]
    Dim Value As Long = 0
    Dim tblLen As Long = SymInfo.count

    Buffer = Byte[].FromString(SymName)
    For i As Integer = 0 To Buffer.Max
        Value = ((31 * Value) + Buffer[i]) Mod TblLen
    Next

    LastHash = Value
    Return value

End

'' returns the table entry with this hash and symbol
'' optionally returns the next empty slot after the hash match
'' builds a chain if in a sublist
Private Sub FindHash(HashValue As Pointer, SymName As String) As Pointer

    Dim index As Pointer = HashValue

    If SymMem.Table[index].Used = False
        Return NoEntry
    Endif

    SymName = Lower(SymName)

    If SymMem.Table[index].Hash = hashValue Then                                                        '' if the hash values match then check actual name incase of collision
        While True
            Dim NameLen As Integer = SymMem.Table[index].NameLength
            If NameLen = SymName.len Then
                Dim cmpresult As Integer = strncmp(SymMem.Table[index].Name.data, SymName, NameLen)
                If cmpresult = 0 Then
                    Return index
                Endif
            Endif
            If SymMem.Table[index].Next = -1 Then Break
            Inc SymInfo.TotalRetryCount
            index = SymMem.Table[index].Next
        Wend
    Endif

    Return NoEntry

End

Private Sub FindEmpty(HashValue As Pointer) As Pointer       '' Returns the next available entry in the symbol table

    Dim index As Pointer = HashValue

    While True
        If SymMem.Table[index].Used = False Then Return index
        Inc index
        If index = HashValue Then Break
        If index = SymInfo.Count Then
            index = 0
            Continue
        Endif
    Wend

    Return noEntry

End

Private Sub InsertHash(rootHash As Long, newElement As Long)

    Dim index As Long = rootHash

    While SymMem.Table[index].next <> -1
        index = SymMem.Table[index].next
    Wend

    SymMem.Table[index].next = newElement
    SymMem.Table[NewElement].Previous = index
    SymMem.Table[NewElement].next = -1
    SymMem.Table[NewElement].Used = True

End

Public Sub GetSymbol(Symbol As String) As Pointer

    Dim MyHash As Pointer = Hash(symbol)

    Return FindHash(MyHash, Symbol)

End

'' Return the slot number insert the name and change the lastupdated time
'' Create a basic variable storage to go along with this symbol
'' Update the virtual address of Var in the table
Public Sub Add(symName As String, value As Variant, Optional HashValue As Long = -1) As Long

    '    Dim result As Pointer

    If SymName = "" Then
        Error.Raise("Symbol name can not be blank")
    Endif

    Symname = Lower(symname)

    If HashValue = -1 Then
        HashValue = Hash(symName)
    Endif

    If $bDebug Then Print Application.id, "Add SymTblmem.exclusive " & SymName
    SymTblMem.Exclusive()
    Dim k As Pointer = FindHash(HashValue, SymName)          '' check if the value exists
    If k = noentry Then                                                                         '' either it exists but does not match or does not exist
        If SymMem.Table[HashValue].Used Then
            Inc SymInfo.Collisions                                                            '' Number of collisions when looking for a free entry
            Dim i As Pointer = FindEmpty(HashValue)
            If i <> noentry Then
                InsertHash(HashValue, i)                                                   '' this sets the next, previous and used fields
            Endif
        Else
            i = HashValue                                                                            '' new entry so mark with no prev or next
            SymMem.Table[i].Used = True
            SymMem.Table[i].next = -1
            SymMem.Table[i].Previous = -1
        Endif
    Endif

    If i = NoEntry Then
        SymTblMem.Release()
        Error.Raise("No More Room In Symbol Table : Used: " & SymInfo.UsedCount & ",Available:" & SymInfo.count & " for " & symname)
    Endif

    SymMem.Table[i].Hash = HashValue

    If $bDebug Then Print Application.id, "Add SymTblmem.Empty hash found " & SymName

    ' result = strncpy(SymMem.Table[i].Name.data, symname, 127)
    If symname.len > 127 Then symname = Left(symname, 127)
    Dim sNewSym As Byte[] = Byte[].FromString(symname)

    For j As Integer = 0 To sNewSym.max
        SymMem.Table[i].Name[j] = sNewSym[j]
    Next
    SymMem.Table[i].Name[j] = 0

    If $bDebug Then Print Application.id, "Add SymTblmem.Symbol name set  " & SymName

    SymMem.Table[i].NameLength = IIf(symname.len > 127, 127, symName.len)

    SymInfo.LastUpdate = Timer

    LastUpdated = SymInfo.LastUpdate

    If $UseCache Then SymbolCache[symName] = i                            ' updated

    SymMem.Table[i].Address = VarMem.set(value)

    Inc SymInfo.UsedCount
    If SymInfo.MaxCount < SymInfo.UsedCount Then
        SymInfo.MaxCount = SymInfo.UsedCount
    Endif

    SymTblMem.Release()
    If $bDebug Then Print Application.id, "Add SymTblmem.release"

End

Public Sub Remove(SymName As String)

    Dim index As Long
    Dim freeData As Pointer

    If $UseCache Then
        UpdateCache() ' updated
        If Not SymbolCache.Exist(SymName) Then ' updated
            Error.Raise("Unknown Symbol " & SymName)
        Endif
        index = SymbolCache[SymName] ' updated
    Else
        index = GetSymbol(SymName)
        If index = NoEntry Then
            Error.Raise("Unknown Symbol " & SymName)
        Endif
    Endif

    If $bDebug Then Print Application.id, "remove SymTblmem.exclusive " & SymName
    SymTblMem.Exclusive()

    freeData = SymMem.Table[index].Address                       ' the address of the data to be freed
    SymMem.Table[index].Address = NoEntry                        ' mark adress as unused
    SymMem.Table[index].Used = False                                    ' mark entry as not used

    If SymMem.Table[index].next <> -1 Then                           ' we have a chain
        If SymMem.Table[index].previous = -1 Then                 ' we have the top of a chain with more links
            TableMove(index, SymMem.Table[index].next)       ' Move the next  entry to this slot
            SymMem.Table[index].previous = -1                           ' the moved value has no previous any more
        Else
            SymMem.Table[SymMem.Table[index].previous].next = SymMem.Table[index].next
        Endif
    Endif

    If $UseCache Then SymbolCache.Remove(SymName) ' updated

    SymInfo.LastUpdate = Timer
    LastUpdated = SymInfo.LastUpdate

    Dec SymInfo.UsedCount

    SymTblMem.Release()

    If $bDebug Then Print Application.id, "remove SymTblmem.release"
    VarMem.Free(Freedata)

End

'' Move/copy  an entry from one location to another
'' update the symbolCache if it is being used
Private Sub TableMove(ToIndex As Long, FromIndex As Long)

    Dim fromPtr As Pointer
    Dim toPointer As Pointer
    Dim ResultPtr As Pointer
    Dim EntryLen As Integer = SizeOf(symbol)
    Dim symName As String = SymMem.Table[FromIndex].Name.ToString()

    fromptr = VarPtr(SymMem) + (EntryLen * FromIndex)
    toPointer = VarPtr(SymMem) + (EntryLen * ToIndex)

    resultptr = memPtr(toPointer, fromPtr, EntryLen)
    If $UseCache Then SymbolCache[SymName] = ToIndex           ' update the cache if being used

End

Public Sub _get(SymName As String) As Variant

    Dim index As Long

    If $UseCache Then
        UpdateCache() ' updated

        If Not SymbolCache.exist(SymName) Then ' updated
            Return $vDefault
        Endif

        index = SymbolCache[SymName]  'updated
    Else
        index = GetSymbol(Symname)
        If index = NoEntry Then
            Return $vDefault
        Endif
    Endif

    If $bDebug Then Print Application.id, "_get ShmSymbolTable VarMem.Lock " & SymName
    VarMem.Lock()
    Dim value As Variant = VarMem[SymMem.Table[index].Address]
    VarMem.Unlock()
    If $bDebug Then Print Application.id, "_get ShmSymbolTable Varmem.UnLock " & SymName
    Return value

End

Public Sub _put(value As Variant, SymName As String)

    Dim SymbolIndex As Pointer
    Dim sym As Symbol
    Dim index As Pointer

    If $UseCache Then
        UpdateCache() ' upated

        If Not SymbolCache.Exist(SymName) Then 'updated
            Add(SymName, Value)
            If SymInfo.NotifyOnNew > 0 Then
                SymbolIndex = SymbolCache["#onnew"]
                Sym = SymMem.Table[SymbolIndex]
                If Sym.NotifyBlock <> 0 Then
                    NotifyVars.SignalEach(Sym, SymName)
                Endif
            Endif
            Return
        Else
            SymbolIndex = SymbolCache[SymName] ' updated
        Endif

    Else
        index = GetSymbol(SymName)
        If index = NoEntry Then
            Add(SymName, Value, lasthash)
            If SymInfo.NotifyOnNew > 0 Then
                index = GetSymbol("#onnew")               ' we need to do this again as the original  hash may only be a bucket
                Sym = SymMem.Table[Index]
                If Sym.NotifyBlock <> 0 Then
                    NotifyVars.SignalEach(Sym, SymName)
                Endif
            Endif
            Return
        Else
            SymbolIndex = index
        Endif
    Endif

    Sym = SymMem.Table[SymbolIndex]
    VarMem.Lock()
    VarMem[Sym.Address] = value
    VarMem.Unlock()

    If Sym.NotifyBlock <> 0 Then
        NotifyVars.SignalEach(Sym)
    Endif

End

Public Sub NotifyQ(symname As String) As ShmList

    Dim sym As Symbol
    Dim index As Long
    Dim ShmQ As ShmList

    index = getsymbol(SymName)
    If index = noentry Then
        Error.Raise("Unknown Sysmbol name " & symname)
    Endif
    sym = SymMem.Table[index]
    If sym.notifyBlock = 0 Then Return Null
    shmq = New ShmList(VarMem, sym.NotifyBlock)
    Return shmq

End

'' We need to determine if the object is a class=module or object=class instanciated object
Public Sub GetObjectClass(BasicObject As Object) As Class

    Dim result As Class = Object.Class(BasicObject)

    If result.Name == "class" Then
        Return BasicObject
    Else
        Return result
    Endif

End

Public Sub NotifyOnNew(Enabled As Boolean, NotifyObject As Object, Optional FuncName As String = "") As Boolean

    If FuncName = "" Then funcName = "OnNew_Created"
    Dim Tag As String = "OnNew_PID{" & Application.id & "}"

    If Enabled Then

        Try Notify("#onnew", NotifyObject, FuncName, 0, Tag)
        If Error Then
            Return False
        Else
            Inc SymInfo.NotifyOnNew
        Endif

    Else If SymInfo.NotifyOnNew > 0 Then
        Try NotifyStop("#onnew", NotifyObject, FuncName, Tag)
        If Error Then
            Return False
        Else
            Dec SymInfo.NotifyOnNew
        Endif
    Endif
    Return True

End

Public Sub Notify(SymName As String, CallBack As Object, Optional FuncName As String = "", Timeout As Long = 0, Tag As String = "")

    Dim ObjClass As Class = Null
    Dim SymbolIndex As Variant

    If $UseCache Then
        SymbolIndex = SymbolCache[SymName]                                                   ' updated
        If Not SymbolIndex Then
            Error.Raise("Unknown Variable " & Quote(SymName))
        Endif
    Else
        SymbolIndex = GetSymbol(SymName)
        If SymbolIndex = noentry Then
            Error.Raise("Unknown Variable " & Quote(SymName))
        Endif
    Endif

    If FuncName = "" Then funcName = SymName & "_Changed"

    objClass = GetObjectClass(CallBack)

    If ObjClass.Exist(FuncName) Then
        NotifyVars.Notify(SymMem.Table[SymbolIndex], CallBack, FuncName, Timeout, Tag)
    Else
        Error.Raise("Unknown Function Name " & FuncName)
    Endif

End

Public Sub NotifyStop(SymName As String, CallObject As Object, Optional CallFunc As String = "", tag As String = "")

    Dim SymbolIndex As Variant

    If $UseCache Then
        SymbolIndex = SymbolCache[SymName] ' updated
        If Not SymbolIndex Then
            Error.Raise("Unknown Variable " & Quote(SymName))
        Endif
    Else
        SymbolIndex = getsymbol(SymName)
        If SymbolIndex = NoEntry Then
            Error.Raise("Unknown Variable " & Quote(SymName))
        Endif
    Endif

    If CallFunc = "" Then Callfunc = SymName & "_Changed"

    NotifyVars.NotifyStop(SymMem.Table[SymbolIndex], CallObject, CallFunc, tag)

End

'' Returns the Virtual Address of the symbol
Public Sub {VarPtr}(SymName As String) As Variant

    Dim index As Long
    Dim value As Variant

    If $UseCache Then
        UpdateCache() ' updated
        If Not SymbolCache.exist(SymName) Then 'updated
            Error.Raise("Unknow Symbol " & SymName)
        Else
            index = SymbolCache[SymName] 'updated
        Endif
    Else
        index = GetSymbol(SymName)
        If index = noentry Then
            Error.Raise("Unknow Symbol " & SymName)
        Endif
    Endif

    value = VarMem.varptr(SymMem.Table[index].Address)
    Return value

End

''Returns a Virtual object pointing to the table entry
Public Sub Entry(SymName As String) As Variant

    Dim index As Long
    Dim value As Variant

    If $UseCache Then
        UpdateCache() ' updated
        If Not SymbolCache.exist(SymName) Then 'updated
            Error.Raise("Unknown Symbol " & SymName)
        Else
            index = SymbolCache[SymName] ' updated
        Endif
    Else
        index = GetSymbol(SymName)
        If index = NoEntry Then
            Error.Raise("Unknown Symbol " & SymName)
        Endif
    Endif

    value = SymMem.Table[index]

    Return value

End

Private Sub TextSummary_Read() As String

    Dim Result As String = ""

    Result &= "\nSymbol Table Listing\nMaxLength = " & SymInfo.MaxCount & ", Available Slots = " & SymInfo.Count & ", Occupied Slots = " & SymInfo.UsedCount &
        ",\nCollisions = " & CLong(SymInfo.Collisions) & ", Search Retry count = " & CLong(SymInfo.TotalRetryCount) &
        "\nLast Updated " & SymInfo.LastUpdate & ", Phy Address " & Hex(SymTblMem.MemoryAddress, 8) & "\n"

    Return result

End

Private Sub Text_Read() As String

    Dim Result As String = ""
    Dim var As Integer

    Result &= TextSummary_Read()

    For Each tem As Variant In Me
        var = $iKeyIndex
        Result &= Format(SymMem.Table[Var].Hash, "####0") & ":" & Left(SymMem.Table[Var].Name.ToString() & Space(25), 25) & " : " & VarMem.text(SymMem.Table[Var].Address) & "\n"
    Next
    Return result

End

Public Sub {Exist}(SymName As String) As Boolean

    Dim index As Long

    If $UseCache Then
        UpdateCache() ' updated
        Return SymbolCache.Exist(SymName) ' updated
    Else
        index = getsymbol(symname)
        If index = noentry Then Return False
    Endif
    Return True

End

'' Wait for a variable to appear with timeout
Public Sub WaitFor(SymName As String, Optional Timeout As Float = 0) As Boolean

    Dim starttime As Float = Timer

    While True

        If $useCache Then
            UpdateCache() ' updated
            If SymbolCache.Exist(symname) Then Break ' updated
        Else
            If GetSymbol(symname) <> noentry Then Break
        Endif

        If timeout > 0 And If Timer - starttime >= timeout Then
            Return False
        Endif

        Wait 0

    Wend

    Return True

End

'' Wait for a specific value to appear in the variable
Public Sub WaitForValue(SymName As String, Value As Variant, Optional timeout As Float = 0) As Boolean

    Dim starttime As Float = Timer

    If WaitFor(SymName, timeout) = False Then Return False

    While Me[symname] <> Value
        Wait 0
        If timeout > 0 And If Timer - starttime >= timeout Then
            Return False
        Endif
    Wend

    Return True

End

'' Wait for a Specified value to diverge from the one specified
Public Sub WaitValueChange(SymName As String, Value As Variant, Optional timeout As Float = 0) As Boolean

    Dim starttime As Float = Timer

    If WaitFor(SymName, timeout) = False Then Return False

    While Me[symname] = Value
        If timeout > 0 And If Timer - starttime >= timeout Then
            Return False
        Endif
        Wait 0
    Wend

    Return True

End

'' Return a list of all symbols, Sorted by text name
Public Sub SortedList() As String[]

    Dim RetList As New String[]

    For i As Integer = 0 To SymInfo.Count - 1
        If SymMem.Table[i].Used And SymMem.Table[i].Address > 0 Then
            RetList.Add(SymMem.Table[i].Name.toString())
        Endif
    Next
    RetList.Sort()
    Return RetList

End

'' iterate through the symbol table in shared memory
'' return the next used slot in the list
Public Sub _next() As Variant

    If Enum.Index = Null Then
        If SymInfo.UsedCount = 0 Then
            Enum.Stop()
            Return
        Endif
        Enum.Index = NextUsedSlot(-1)
        $sKey = SymMem.Table[Enum.Index].Name.toString()
        $iKeyIndex = Enum.index
    Else
        Enum.index = NextUsedSlot(Enum.index)
        If Enum.index = -1 Then
            Enum.Stop()
            Return
        Endif
        $sKey = SymMem.Table[Enum.Index].Name.toString()
        $iKeyIndex = Enum.index
    Endif

    Return VarMem[SymMem.Table[Enum.index].Address]

End

'' Return the next used slot given the starting point to search
Private Sub NextUsedSlot(index As Long) As Long

    Inc index
    While Index < SymInfo.Count And SymMem.Table[index].Used = False
        Inc index
    Wend
    If Index >= SymInfo.Count Then
        index = -1
    Endif
    Return index

End

'' return the number of entries in the actual symbol table
Private Function count_Read() As Integer

    Return SymInfo.UsedCount

End

'' return the max number of last  symbol for iteration through the list
Private Function Max_Read() As Integer

    Return SymInfo.UsedCount - 1

End

'' The number of slots in the symbol table
Private Function Length_Read() As Integer

    Return SymInfo.Count

End

Private Function Key_Read() As String

    Return $sKey

End

Private Function KeyIndex_read() As Long

    Return $iKeyIndex

End

Private Function Default_Read() As Variant

    Return $vDefault

End

Private Sub Default_Write(Value As Variant)

    $vDefault = Value

End

Private Function MaxSymbols_Read() As Integer

    Return SymInfo.Count

End

'' returns the number of collisions using the hash function
Private Function Collisions_Read() As Integer

    Return SymInfo.Collisions

End

'' return the highest number of sysmbols at any one time
Private Function MaxUsedSymbols_Read() As Integer

    Return SymInfo.MaxCount

End
